Update Aug 16:

thanks to Matteo we are using option 2 directly on Coq code:

-------------------

The idea is to reify Inductive definitions into something that fpc-pbt can handle.

We restrict to Inductive defs that can be seen as pure (higher-order) Horn clauses, so:

- no interpreted functions (computations) inside. In the future we
  could conceivably map functions (from the basic Coq library) to
  relations

- No polymorphism -- exactly as QuickChick, since how can you generate polymorphic data?

- No GADT and other term dependencies. Again, we cold turn LF-like specs into lambda-Prolog as well known, but not right now.

It still leaves us with plenty of examples, e.g. from SF: IndProp.v,
Types.v (progress and pres for a simple arithmetic language), TIMP.v
(a typed version of IMP from the QC book).

In the PPDP paper, the kernel was basically a decorated sequent calculus for uniform proofs of Horn logic (plus nabla, which does not hurt, but we'll likely not use). See also seq.thm in the Abella library.

While reifying a program we have at least 3 choices: let's use the ordered example

1. multiple prog clauses

prog (ord null) tt.
prog (ord (cons X null)) (is_nat X).
prog (ord (cons X (cons Y Rs))) (and (leq X Y) (ord (cons Y Rs))).

2. single prog clause (aka the completion)

progs (ord L)
      [(np "o_n" (eq L null)),
      (np "o_c1" (and (eq L (cons X null)) (is_nat X))),
      (np "oc_2" (and (eq L (cons X (cons Y Rs))) (and (leq X Y) (ord (cons Y Rs))))) 
            ].

here we have explicit equations in a body as a list of alternatives.
[DM: Adding existential quantifiers to the body of these clauses would
 make the scope of quantification clear and makes the following
 explicit presentation possible.]

3. explicit fixed point presentation, where we abstract over ord.

PPDP uses 2. because it helps with random backchaining (just permute
the body). To reify from Coq it could be simpler to use 1. (changing
the kernel takes 2 minutes), where each constructor yields a single
prog clause, possibly with its name that may be useful for
explanations. I think there is a MetaCoq plug in that may help to put
explicit equations in constructors (using JMeq).  Option 3. would also
be good since it opens the door to doing much more with Inductive than
using constructors as intro rules.


In any case, to reify the Inductive ordered, I hope we can just quote
Coq's term (e.g. null would be {{ nil }}). We will need to reify of
course prog for nat, list etc from their respective Inductive
defs. Right now, I would leave writing the actual PBT query to the
user, although it's possible to derive it from a Conjecture.
