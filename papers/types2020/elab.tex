\newpage
\section{Elaboration of external proof certificates for the Coq
  kernel}

% Follow the text in \cite{blanco20coq}.

The trusted base of Coq is its kernel, which is a type-checking
program that certifies that a dependently typed $\lambda$-term has a
given type.  If type checking succeeds, the formula corresponding to
that type is, in fact, accepted by Coq users as a theorem of
intuitionistic logic.  The rest of the Coq system, especially its
tactic language, is designed to help a human user build
proofs-as-$\lambda$-terms that can be checked by the kernel.

There are many theorem provers for intuitionistic logic for which a
successful proof is not the kind of detailed $\lambda$-term required
by the Coq kernel.  Most prover provide, instead, a trace of some key
aspects of a proof: some details are often not included in such a
trace.  For example:
\begin{enumerate}

\item Substitution instances of quantifiers might not be recorded in a
  proof since such instances can, in principle, be reconstructed using
  unification.

\item Detailed typing information might not need to be stored within a
  proof since types can often be reconstructed during proof checking.

\item Some simplifications steps might be applied within a proof
  without recording which rewrites were used.  A simple 
  non-deterministic proof-search engine might be expected to
  reconstruct an equivalent simplification.
\end{enumerate}

As we have describe above, the Foundational Proof Certificate (FPC)
framework has been designed for formally defining a rich collection of
proof certificates that do not necessarily contain full details.
Proof checkers for FPC certificates can be written using simple logic
programs: the standard implementation mechanisms of unification and
backtracking search can then be used to reconstruct missing proof
details \cite{miller17fac}.  Such proof checking kernels can also be
used to elaborate such certificates into fully detailed proofs
\cite{blanco17phd,blanco17cade}.

We describe here briefly how to use the technology behind FPCs and
logic programming in order to provide a flexible approach to
connecting external provers of intuitionistic logic to Coq.
%
Following the general outline that has been described in
\cite{blanco17cade}, we assume that the following step are taken.
%
\begin{enumerate}
\item Have an external prover output some form of proof evidence
  (proof certificate) for formulas it claims are theorems.

\item Develop a formal definition of the semantics behind such proof
  certificates using the FPC framework.

\item Check proofs by executing the logic programming checker that is
  parametrized by the particular FPC definition.
\end{enumerate}
%
It is also possible to pair two different proof certificates, defined
by two different FPC definitions, and do the proof checking in
parallel.  The logic programming setting allows such parallel checking
to also serve as checking-and-synthesizing.  That is, during the
checking of one certificate, it is possible to synthesize, for
example, a fully detailed term that is appropriate for handing to the
Coq kernel.

If one is interested only in building Coq kernel proof structures, we
can bypass the use of an explicit pairing operation and build the
synthesis of such proof structures directly into the FPC proof
checker.  If one is interested in checking only one kind of external
proof structure, then the FPC for that structure could also be built
into the checker (via, say, partial evaluation of logic programs
\cite{lloyd91jlp}).

To illustrate the possibilities ***



** We limit our attention here to first-order intuitionistic logic:
that is, we do not consider here inductive definitions.

** Note that with intuitionistic logic, there is much less ambiguity
of polarities possible.  In particular, only the conjunction and the
atomic formulas can have ambiguous polarizations.  The two
conjunctions are familiar to those working with typed
$\lambda$-calculus: 

the negative conjunction (corresponding to $\with$ in linear logic)
corresponds to surjective pairing.

the positive conjunction (corresponding to $\with$ in linear logic)
corresponds to ***.

The choice between negated atoms and positive atoms is similar to the
choice in representing $\beta$-normal terms using either head-normal
form or administrative normal form.



We built the fpccoq system to demonstrate the feasibility of using
logic programming to check proof certificates produced by external
provers and to elaborate such certificates into proofs with sufficient
details that they can be given directly to Coq's kernel to
check.  Note that one does not need to trust the external prover nor
the fpccoq tool-chain: one only needs to trust the Coq kernel.


De Bruijn
decide depth
simply typed lambda terms


\newpage

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
