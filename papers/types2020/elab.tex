\section{Elaboration of external proof certificates for the Coq kernel}
\label{sec:elab}

The trusted base of Coq is its kernel, which is a type-checking
program that certifies that a dependently typed $\lambda$-term has a
given type.  If type checking succeeds, the formula corresponding to
that type is, in fact, accepted by Coq users as a theorem of
intuitionistic logic along with any axioms that have been adopted.
The rest of the Coq system, especially its tactic language, is
designed to help a human user build proofs-as-$\lambda$-terms that can
be checked by the kernel.

There are many theorem provers for intuitionistic logic
\cite{raths07jar} for which a successful proof is not the kind of
detailed $\lambda$-term required by the Coq kernel.  Often, such
provers provide no information about the proofs they discover.  To the
extent that some  evidence is output after a successful run, such
evidence is usually just a trace of some key aspects of a proof, where some
details are often not included.  For example:
\begin{enumerate}

\item Substitution instances of quantifiers might not be recorded in a
  proof since such instances can, in principle, be reconstructed using
  unification.

\item Detailed typing information might not need to be stored within a
  proof since types can often be reconstructed during proof checking.

\item Some simplifications steps might be applied within a proof
  without recording which rewrites were used.  A simple 
  non-deterministic proof-search engine might be expected to
  reconstruct an equivalent simplification.
\end{enumerate}

As we have describe in Section~\ref{sec:three}, the Foundational Proof
Certificate (FPC) framework has been designed for formally defining a
rich collection of proof certificates that do not necessarily contain
full details.  Proof checkers for FPC certificates can be written
using simple logic programs: the standard implementation mechanisms of
unification and backtracking search can then be used to reconstruct
missing proof details \cite{miller17fac}.  Such proof checking kernels
can also be used to elaborate such certificates into fully detailed
proofs \cite{blanco17phd,blanco17cade}.

We describe here briefly how to use the technology behind FPCs and
logic programming in order to provide a flexible approach to
connecting external provers of first-order intuitionistic logic to
Coq.
%
Following the general outline that has been described in
\cite{blanco17cade,blanco20coq}, we assume that the following step are
taken.
%
\begin{enumerate}
\item Have an external prover output some form of proof evidence
  (proof certificate) for formulas it claims are theorems.

\item Develop a formal definition of the semantics behind such proof
  certificates using the FPC framework.

\item Check proofs by executing the logic programming checker that is
  parameterized by the particular FPC definition.
\end{enumerate}
%
It is also possible to pair two different proof certificates, defined
by two different FPC definitions, and do the proof checking in
parallel.  The logic programming setting allows such parallel checking
to also serve as checking-and-synthesizing.  That is, during the
checking of one certificate, it is possible to synthesize, for
example, a fully detailed term that is appropriate for handing to the
Coq kernel.

If one is interested only in building Coq kernel proof structures, we
can bypass the use of an explicit pairing operation and build the
synthesis of such proof structures directly into the FPC proof
checker.  (We took exactly this step in Figure~\ref{fig:augmented}
where proof checking involved both proof certificates as well as
Coq-term structures.)  If one is interested in checking only one kind
of external proof structure, then the FPC for that structure could
also be built into the checker (via, say, partial evaluation of logic
programs \cite{lloyd91jlp}).

As an example, consider an external theorem prover for propositional
intuitionistic logic which return proof structures that are De Bruijn
expressions for the underlying untype $\lambda$-proof that encodes
(part of) the proofs it finds.  Consider the De Buijn expression
example at the end of Section~\ref{ssec:beyond}.  This can be used as
evidence that the following is a theorem of Coq.

\begin{lstlisting}[basicstyle=\ttfamily,language=lprolog]
Theorem dneg_peirce_mid : forall P Q: Prop, (((((P -> Q) -> P) -> P) -> Q) -> Q).
\end{lstlisting}

Of course, the proof information in the untyped term must be
elaborated to be a fully typed and functional expression.  Proof
checking using the FPC in Figure~\ref{fig:debruijn} and (an extension
of) the proof Figure~\ref{fig:kernel}.

***
presents the  specific FPC that defines the proof semantics of using
the De Bruijn notions for untyped $\lambda$-terms as proof evidence of
a proof in intuitionistic propositional logic.

\begin{metanote}
  AM: I think we need more: the FPC may go to the appendix, we may want to say that there is a tactic that proves these theorems etc. 
\end{metanote}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

% LocalWords:  intuitionistic
