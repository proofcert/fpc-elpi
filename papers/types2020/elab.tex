%\newpage
\section{Elaboration of external proof certificates for the Coq
  kernel}

% Follow the text in \cite{blanco20coq}.

The trusted base of Coq is its kernel, which is a type-checking
program that certifies that a dependently typed $\lambda$-term has a
given type.  If type checking succeeds, the formula corresponding to
that type is, in fact, accepted by Coq users as a theorem of
intuitionistic logic.  The rest of the Coq system, especially its
tactic language, is designed to help a human user build
proofs-as-$\lambda$-terms that can be checked by the kernel.

There are many theorem provers for intuitionistic logic
\cite{raths07jar} for which a successful proof is not the kind of
detailed $\lambda$-term required by the Coq kernel.  Often, such
provers provide no information about the proofs they discover.  To the
extent that some prove evidence is output after a successful run, such
evidence is usually just a trace of some key aspects of a proof: some
details are often not included in such a trace.  For example:
\begin{enumerate}

\item Substitution instances of quantifiers might not be recorded in a
  proof since such instances can, in principle, be reconstructed using
  unification.

\item Detailed typing information might not need to be stored within a
  proof since types can often be reconstructed during proof checking.

\item Some simplifications steps might be applied within a proof
  without recording which rewrites were used.  A simple 
  non-deterministic proof-search engine might be expected to
  reconstruct an equivalent simplification.
\end{enumerate}

As we have describe in Section~\ref{sec:three}, the Foundational Proof
Certificate (FPC) framework has been designed for formally defining a
rich collection of proof certificates that do not necessarily contain
full details.  Proof checkers for FPC certificates can be written
using simple logic programs: the standard implementation mechanisms of
unification and backtracking search can then be used to reconstruct
missing proof details \cite{miller17fac}.  Such proof checking kernels
can also be used to elaborate such certificates into fully detailed
proofs \cite{blanco17phd,blanco17cade}.

We describe here briefly how to use the technology behind FPCs and
logic programming in order to provide a flexible approach to
connecting external provers of first-order intuitionistic logic to
Coq.
%
Following the general outline that has been described in
\cite{blanco17cade}, we assume that the following step are taken.
%
\begin{enumerate}
\item Have an external prover output some form of proof evidence
  (proof certificate) for formulas it claims are theorems.

\item Develop a formal definition of the semantics behind such proof
  certificates using the FPC framework.

\item Check proofs by executing the logic programming checker that is
  parametrized by the particular FPC definition.
\end{enumerate}
%
It is also possible to pair two different proof certificates, defined
by two different FPC definitions, and do the proof checking in
parallel.  The logic programming setting allows such parallel checking
to also serve as checking-and-synthesizing.  That is, during the
checking of one certificate, it is possible to synthesize, for
example, a fully detailed term that is appropriate for handing to the
Coq kernel.

If one is interested only in building Coq kernel proof structures, we
can bypass the use of an explicit pairing operation and build the
synthesis of such proof structures directly into the FPC proof
checker.  If one is interested in checking only one kind of external
proof structure, then the FPC for that structure could also be built
into the checker (via, say, partial evaluation of logic programs
\cite{lloyd91jlp}).

To illustrate this approach to elaborating externally provided proof
structures into terms the Coq kernel can check, we consider here
examples take from the file \verb+coq_fpc.v+, which is part of the
repository \url{https://github.com/proofcert/fpc-elpi/}.
Figure~\ref{fig:debruijn} presents the specific FPC that defines the
proof semantics of using the De Briujn notions for untyped
$\lambda$-terms as proof evidence of a proof in intuitionistic
propositional logic.  That FPC definition, along with a proof checker
capable of synthesizing Coq proof terms during proof checker, makes it
possible to use the term denoting the untyped $\lambda$-term
$\lambda x (x (\lambda y (\lambda z (x (\lambda u z)))))$

\begin{lstlisting}[basicstyle=\ttfamily,language=lprolog]
(lambda (apply 0 [lambda (apply 0 [lambda (apply 2 
                                                    [lambda (apply 1 [])])])]))
\end{lstlisting}
as a proof of following theorem of Coq.
\begin{lstlisting}[basicstyle=\ttfamily,language=lprolog]
Theorem dneg_peirce_mid : forall P Q: Prop, (((((P -> Q) -> P) -> P) -> Q) -> Q).
\end{lstlisting}

\begin{figure}
\lstinputlisting[basicstyle=\ttfamily,language=lprolog,linerange={start-end}]{code/deb-fpc.sig}
\lstinputlisting[basicstyle=\ttfamily,language=lprolog,linerange={start-end}]{code/deb-fpc.mod}
\caption{The FPC definition of De Bruijn notation as proof evidence.}
\label{fig:debruijn}
\end{figure}




%\newpage

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
