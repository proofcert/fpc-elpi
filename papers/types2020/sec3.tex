%\newpage
\section{Proof theory and proof certificates}
\label{sec:three}

% {\color{red} The goal in this section is to say a bit about focusing
%   generally, and to give a bit of detail about FPC for Horn clauses.
%   Initial draft of text taken from \cite{blanco19ppdp}.
% }

\begin{metanote}
  (AM): Start with the logical reconstruction of \texttt{check}, to and then reverse engineer what we want/need to say about focusing and FPC. We \textbf{do} not talk about PBT yet, just logic programming (with proof terms). % In sec 4 we package \texttt{check} in a PBT query and explain how \texttt{check} works for term generation.
% One way to proceed:
  % \begin{itemize}
  % \item One figure fig \ref{fig:interp} for Horn logic over Coq terms (no certificates) and its encoding with quotations 
  % \item Then the logic behind the dependent kernel with certificates and proof terms
  % \end{itemize}
%
Stuff in red is from old paper
\end{metanote}

\subsection{Focused proof systems with certificates}
\label{ssec:focused}
\todo{Adapt the discussion}
\todo{grammar for formulae and proof terms \cite{Herbelin94,LengrandDM06}  or just the figure? Mention spine calculus}


The proof search approach to encoding Horn clause computation
results in the structuring of proofs with repeated
switching between a \emph{goal-reduction} phase and a
\emph{backchaining} phase~\cite{miller91apal}.

%
{\color{red}
The notion of \emph{focused proof systems}~\cite{andreoli92jlc,liang09tcs}
generalizes this view of proof construction by identifying the
following two phases. % of proof construction.
\begin{enumerate}
\item The \emph{negative}%
% \footnote{The terminology of negative and positive phases is a bit
%   unfortunate: historically, these terms do not refer to positive or negative
%   subformula occurrences but rather to certain semantic models used in
%   the study of linear logic~\cite{girard87tcs}.}
%
  phase corresponds to  goal-reduction: in this phase,
  inference rules that involve \emph{don't-care-non\-de\-ter\-min\-ism} are
  applied.
%
  As a result, there is no need to consider backtracking over choices
  made in building this phase.

\item The \emph{positive} phase corresponding to  backchaining: in this phase, inference rules that involve
  \emph{don't-know-non\-de\-ter\-min\-ism} are applied: here,
  inference rules need to be supplied with information in order to
  ensure that a completed proof can be built.
%
  That information can be items such as which term is needed to
  instantiate a universally quantified formula and which disjunct of a
  disjunctive goal formula should be proved.
\end{enumerate}
%
Thus, when building a proof tree (in the sequent calculus) from the
conclusion to its leaves, the negative phase corresponds to a simple
computation that needs no external information, while the positive
phase may need such external information to be supplied.
%
In the literature, it is common to refer to a repository of such
external information as either an \emph{oracle} or a \emph{proof
certificate}.
}


%\subsection{Certificate checking with expert predicates}
%\subsection{Adding certificates and experts to a proof system}
%\label{ssec:fpc}

\todo{Figure now uses Dale kernel-v2 --- needs further abstraction and explanation, see appendix}
\begin{footnotesize}
\begin{figure}
    \newcommand{\XXi}{{\color{blue}{\Xi}}}

  \newcommand{\bc}[5]{#1;#2\vdash #3 : #4 \Downarrow #5}
\[
% \infer{\XXi\vdash t = t}
% {%\eqExpert{\XXi}
% }
% \qquad
% \infer{\XXi\vdash \true}
% {%\trueExpert{\XXi}
% }
% \qquad
% \infer{\XXi\vdash G_1\vee G_2}
% {\XXi\vdash G_i%\qquad \orExpert{\XXi}{\XXi'}{i}
% }
% \qquad
% \infer{\XXi\vdash \exists x. G}
% {\XXi\vdash G[t/x]%\qquad \someExpert{\XXi}{\XXi'}{t}
% }
% \qquad 
\infer{\XXi;\Gamma\vdash \lambda x:A.\,t : \forall x : A.\,  G}
{\XXi;\Gamma, x : A\vdash t : G%\quad \andExpert{\XXi}{\XXi_1}{\XXi_2}
}
\qquad
\infer{\XXi;\Gamma\vdash t : A}
      {\bc{\XXi}{\Gamma} t D A \quad D \in \Pscr\cup\Gamma}
\]
\vskip -18pt
\[
  \infer{\bc {\XXi}{\Gamma} {[]} A A}{\trueExpert{\XXi}}{}\qquad
%  \infer{\bc{\forall x.\, D} A}{\bc{D[t/x]} A}{}\qquad
  \infer{\bc{\XXi}{\Gamma}{(t\ l)} {\forall x:B.\, D} A}
  {\XXi_1;\Gamma\vdash t : A\qquad \bc{\XXi_2}{\Gamma}l {B[t/x]} A\qquad\prodExpert{\XXi}{\XXi_1}{\XXi_2}}{}
\]
%\lstinputlisting[linerange={interp-end}]{code/dep-kernel.mod}
\caption{dep kernel.}
\label{fig:augmented}
\end{figure}
\begin{figure}
%\lstinputlisting[linerange={sigs-end}]{code/dep-kernel.sig}
\lstinputlisting[linerange={check-end}]{code/dep-kernel-v2.mod}
\caption{Implementation of a  dependent kernel for Coq terms.}
\label{fig:kernel}
\end{figure}
\end{footnotesize}



Figure~\ref{fig:augmented} contains a simple proof system \dots  in which each inference rule is augmented with an
additional premise involving an \emph{expert predicate}, a
certificate $\Xi$, and possibly continuations of certificates ($\Xi'$,
$\Xi_1$, $\Xi_2$) with extracted information from certificates (in the
case of $\vee$ and $\exists$).
%
%
%
\todo{Explain relations with other term assignments. Note that we do not use explicit substitutions (we are cut free). Explain the choice of not having certificates represent proof terms. Explain that the unfold clause handles defined atoms and defined connectives (conjunction, disjunction, existential and also equality): this may be less efficient and proof-theoretically induce pointless phase changes, but it is arguably very elegant e simplifies proof terms that arand inherited by Coq }

Figure~\ref{fig:kernel} contains the Elpi implementation of the
inference rules in Figure~\ref{fig:augmented}: here the infix
turnstile $\vdash$ symbol is replaced by the \lsti{check} predicate.
%
% Notice that it is easy to show that no matter how the expert predicates
% are defined, if the goal \lsti{check Cert B} is provable in \lP then
% \lsti{B} must be a sound consequence of the program clauses stored in
% \dots
% the \lsti{prog} predicate (which provides a natural implementation of
% the premise $(A~\hbox{\tt :-}~G)\in\instan{\Pscr}$.
% AM: not there
% in Figure~\ref{fig:kernel}). 

%\subsection{Certificates}

\todo{What happened to the unfold certificate???}
% \todo{Show the dprolog tactic? have an example? could  be
% \lsti{Goal  exists R, insert 2 [0;1] R.} and we would move the code for insert here}
{\color{red}}
The notion of proof certificates
 is taken from the general setting of \emph{foundational
  proof certificates}~\cite{chihani17jar}.
%
In our case here, an FPC is a collection of \lP clauses that
provide the remaining details not supplied in Figure~\ref{fig:kernel}:
that is, the exact set of constructors for the \lsti{cert} type as
well as the exact specification of the expert predicates listed in
that figure.
%
Figure~\ref{fig:resources} displays two such FPCs,
both of which can be used to describe proofs where we bound
the number of occurrences of unfoldings in a proof.
%
For example, the first FPC
provides the experts for treating certificates that are constructed
using the \lsti{qheight} constructor.
%
As is easy to verify, the query \mbox{\lsti{(check (qheight 5) B)}} is
provable in  the kernel using the clauses in Figures~\ref{fig:kernel}
and~\ref{fig:resources} if and only if the height of that proof is 5
or less.
%
Similarly, the second FPC uses the constructor \lsti{qsize} (with two
integers) and can be used to bound the total number of instances of
unfoldings in a proof.
%
%In particular, the query \mbox{\lsti{(check (qsize 5 H) B)}}
% \begin{lstlisting}
% sigma H\ (check (qsize 5 H) B)
% \end{lstlisting}
%is provable if and only if the total number of unfoldings of that
%proof is 5 or less.

\begin{figure}
\lstinputlisting[linerange={resources-end}]{code/fpcs.sig}
\lstinputlisting[linerange={resources-end}]{code/fpcs.mod}
\caption{Two FPCs that describe proofs that are limited in either
  height or in size.}
\label{fig:resources}
\end{figure}


Further, if we view a particular FPC as a means of restricting proofs, it is
possible to build an FPC that \emph{restricts} proofs satisfying two FPCs
simultaneously.
%
% In particular, Figure~\ref{fig:pairing} defines an FPC based on the
% (infix) constructor \lsti{<c>}, which \emph{pairs} two terms of type
% \lsti{cert}.
%
The pairing experts for the certificate \lsti{Cert1 <c> Cert2} simply
request that the corresponding experts also succeed for both
\lsti{Cert1} and \lsti{Cert2} 
%
Thus, the query \lsti{check ((qheight 4) <c> (qsize 10)) B}
will succeed if there is a proof of \lsti{B} that has a height less
than or equal to 4 while also being of size less than or equal to 10.

% Various  additional examples and experiments using the pairing of FPCs
% can be found in~\cite{blanco17cade}. Using similar techniques, it is possible to define FPCs that target
% specific types for special treatment: for example, when generating
% integers, only (user-defined) small integers could be produced.


\subsection{A prolog-like tactic}

\begin{metanote}
  Let's dump it here and see how it looks
\end{metanote}

\begin{lstlisting}
Elpi Accumulate lp:{{
  solve [str ''height'', int N] [goal _Ctx Ev G _Who] _OutGoals :-
    coq.say "Goal:" {coq.term->string G},
    check (qheight N) (go G Term),
    Ev = Term,
    coq.say "Proof:" {coq.term->string Ev}.
...
}}.
\end{lstlisting}
The following example show how we can do FPC-driven logic programming in Coq and return
a Coq term
\begin{lstlisting}
Inductive insert (x:nat) : list nat -> list nat -> Prop :=
| i_n : is_nat x -> insert x [] [x]
| i_s : forall y: nat, forall ys, x <= y -> insert x (y :: ys) (x :: y :: ys)
| i_c : forall y: nat, forall ys rs, y <= x -> insert x ys rs -> insert x (y :: ys) (x :: rs).
Lemma i1:  exists R, insert 2 [0;1] R.
eexists.
elpi  dprolog 10.
Qed.
Print i1.
ex_intro (fun R : list nat => insert 2 [0; 1] R) [0; 1; 2]
  (i_c 2 0 [1] [1; 2] (i_c 2 1 [] [2] (i_n 2)) : exists R : list nat, insert 2 [0; 1] R
\end{lstlisting}

The \lsti{dprolog} tactic can be seen as a programmable version of
Coq's \lsti{auto}: it currently lacks the latter capability of solving
goals by \lsti{reflexivity} and the modularity capability of using
\lsti{Hints}, but it is not compelled to use depth-first search, since it follows the dictate of the given FPC. For example the FPC can provide a \emph{trace}, which may be more customable that the one offered by the \lsti{Debug} option.
%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

% LocalWords:  backchaining disjunct LJT dep qheight qsize orE someE
% LocalWords:  Elpi modularity
