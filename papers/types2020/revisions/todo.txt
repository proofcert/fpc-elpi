%% files for things to take care for the reviewers (R) and additional comments
%% in second reading


-- paper --


changebar for new stuff?

README.md for code updated (the existing one refers to the ijcar subsmission)

R1
- page 1: put some references for
"that has not been given a satisfactory representation in type theory"
and for
"have difficulty treating linear negation and the multiplicative disjunction"
[TODO DALE]


 R1:
  An introduction to the topic, or at
least a section explaining the application in the paper, would be
necessary to open the paper to a larger audience. However, that
requires space. Personally, I would suggest the authors to sacrifice
part of Section 2 for this.

[TODO DALE]
AM:
pag 5: \caption{Specification of the checking of a proof certificate and the
  synthesis of a dependently typed $\lambda$-term.}

It's not a lambda calculus in so far it does not have variable sor abstraction. In general,  the caption does not read well

\caption{Implementation of a  dependent kernel for Coq terms.}
Again, inprecise: what is dependent? what coq terms?

pag 7: prod_e takes 4 argument, the relative code 3 (no subst term, of course because of unification). Comment?

page 8: in the def of insert, i_n has a is_nat assumption. Really needed here?

R1
you are re-implementing a better eauto. However, your
implementation only applies as lemmas constructors of an inductive type.
Note: I understand, because I know it in advance, that a reason could be
that you plan to use LP negation as failure in the later section on testing.
Therefore you need a close world specification. If that's the main reason,
it should be made explicit in the paper.

[AM: I don't think that's it. If i have an inductive predicate p and then prove a lemma about p, this does not violate the CWA, since, well, the lemma is true in the same least model of p]

-------------

NEW

-- If unify-eq works, reformulate inint and eq in the calculus to
apply modulo conversion (in which context???). In ref manual (page
16), reduction is defined as

E[Gamma] |- t |> u

Conversion as E[Γ] ⊢ t1 =_{βδιζη} t2 . defined as equi-reduction modulo eta-expansion
(and irrelevant (?) subterms)


Now we  say the local context is empty and
the global one is just Inductive, but coq.unify-eq must use these context

From manual:
A ** local context** is an ordered list of declarations of variables. The
declaration of a variable x is either an assumption, written x ∶ T
(where T is a type) or a definition, written x ∶= t ∶ T .

A **global environment** is an ordered list of declarations. Global
declarations are either assumptions, definitions or declarations of
inductive objects. assumptions are written as (c ∶ T ), indicating
that c is of the type T . Definitions are written as c ∶= t ∶ T 

-- add certificate so sort rule!

-- if we get the tactics to work with Hints, we need a new decide rule
   (or change the one we have).
