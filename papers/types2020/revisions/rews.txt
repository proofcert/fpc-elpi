

--- report 1 --- The paper build on the Coq-Elpi plugin in order to
implement in LambdaProlog/Elpi a tactic and a property based tester
for relational Coq specifications, i.e. the restriction of Coq to the
style where logic programs (made of Horn clauses) are encoded as
inductive types to capture specifications. The alternative in Coq is
to use instead computable functions, in the spirit of functional
programming.

The paper only contains a couple of proofs of concept, but it is very
convincing: with only a limited amount of lines of Coq-Elpi code the
authors implement an eauto-style tactic that can be controlled easily
via foundational certificates and a PBT that works on relational
specification. Both are incomparable in features to the
well-established corresponding Coq tools (eauto and QuickChick): for
example, when using the relational style, QuickChick requires some
massaging of the formalization to be used, which is unnecessary
here. The use of foundational certificates paves the way to a lot of
applications, like: importing proofs from external provers in an
uniform way; combining different kinds of proof searches and limits;
automatic generation of traces and proof terms for internal usage or
for exportation to other tools; user-directed proof searches via
domain specific knowledge (to be incorporated in the form of
LambdaProlog clauses).

The paper is in scope for TYPES and I would recommend it strongly if
it weren't for the presentation. On the one hand the English is very
good and each sentence can be easily read. On the other hand I believe
the paper to be inaccessible to readers that do not have a background
in logic programming (so far so good) and proof certificates in the
sense of the Foundational Proof Certificates EU project lead by the
second author (very few I fear). An introduction to the topic, or at
least a section explaining the application in the paper, would be
necessary to open the paper to a larger audience. However, that
requires space. Personally, I would suggest the authors to sacrifice
part of Section 2 for this.

Minor remarks:
- page 1: put some references for
"that has not been given a satisfactory representation in type theory"
and for
"have difficulty treating linear negation and the multiplicative disjunction"
[TODO DALE]
- page 5, Figure 1: the first inference rule (the decide inference rule) seems
wrong. Indeed you are adopting Coq's syntx Ind[p](\Gamma_I := \Gamma_C)
where p is a list of abstractions over so called uniform parameters.
You seem to never instantiate them in the rule. Moverover, the premise
"(head A : T) \in \Gamma_I" is also suspicious. I would expect
that premise to compute a substitution \sigma for p, to be applied to D
in both premises (e.g. D\sigma).

[AM: I agree that head A is imprecise: we mean the head symbol of A.]

The alternative is that the parameters are explicitly quantified both in
\Gamma_i and \Gamma_C (the way the inductive type packet is represented
internally into Coq) and p becomes just a number that says how many of the
abstractions are parameters. For your purposes, this number can also be
dropped entirely from the presentation.

[Let's take the latter alternative]
This point needs a clarification.

- section 3: you are re-implementing a better eauto. However, your
implementation only applies as lemmas constructors of an inductive type.
eauto can use any lemma/theorem whose type is an Horn clause.
It is misterious why you choosed to only use constructors: you never
justify this restriction. There is also an hint that you can use the Hints
that eauto uses, but this is not reflected in your code. How can it be?

Note: I understand, because I know it in advance, that a reason could be
that you plan to use LP negation as failure in the later section on testing.
Therefore you need a close world specification. If that's the main reason,
it should be made explicit in the paper.

--- report 2 ---

Summary: The paper presents two tactics for Coq making use of the new λ-Prolog engine *Coq-Elpi*. The first tactic is a proof search tactic that can be constrained to finding proofs of certain characteristics, like the width and depth of its proof tree. The second is a property-based testing tactic to find counterexamples to theorems.  The ideas of the paper are based on previous work by some of the authors, namely, the use of λ-Prolog to perform proof search, in the theoretical framework called the Foundational Proof Certificates (FPC).

The two tactics developed by the authors are interesting, both as examples of the benefits of using λ-Prolog in Coq, and as examples of useful tactics to have in the toolbox of a prover. However, the paper suffers from the following two issues, and as such I cannot fully support it:

 1. The paper is centered on the idea that it is possible to use Coq-elpi to construct tactics following the ideas from FPC, but it lacks a proper evaluation of the tactics to show its benefits. It would make for a stronger story to have a thorough evaluation with its competitors (eauto for the first tactic and QuickChick for the second), even in restricted scenarios.

 2. The code is not available. The cited https://github.com/proofcert/fpc-elpi returns 404, and the search for fpc-elpi failed, as well inspecting the repos from the proofcert organization.

As some minor remarks, let me add the following comments:

 1. The proof term shown as the result of calling the tactic to prove i1 is missing some terms, namely, the inequalities proofs. Are these also automatically obtained by the tactic?
[DONE]
 2. Several figures have glitches.
[would be nice to know which]
 3. The font in the figure of 3.2.1 is different from the one used in the previous figures.
[DONE]

