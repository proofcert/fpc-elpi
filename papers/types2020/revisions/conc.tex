\section{Conclusion and future work}

This paper follows on a line of research starting in the late 80's and
gaining more steam in the last five years, which advocates the
usefulness of proof theory and higher-order logic programming for the
many tasks concerning the development, enrichment and even formal
verification of proof assistants. The development of the Coq-Elpi
plug-in has made this connection tighter.

We have presented two application of this synergy: one supporting an
out-of-the-box way to do property-based testing for inductive
relations; the other geared towards providing a flexible approach to
connecting external provers of first-order intuitionistic logic to Coq
%

%\todo{sum up contribution}

 The
code reported in Fig.~\ref{fig:augmented} is a simplification for
exposition purposes of the real implementation of the
kernel. Following ideas from bidirectional type checking, we have
factored out the product left rule in $\forall-L$ and $\supset-L$,
where the former delegates to Coq the \emph{check} that the
instantiation term $t$ is well-typed w.r.t.~$B$, while in the latter
proof search will \emph{generate} such a term, given the type
$B$. There are also other minor tweaks, such as
a rule performing weak-head reduction (allowing
us to handle directly existential goals).

There are many avenues of developments for this line of research. 
We would like to exploit one of distinguished features of Elpi: the
\emph{delay} mechanism.  The use of constraints for data generation is
well developed~\cite{FioravantiPS15} and we could try to leverage it
to improve our PBT tactic so as to generate partially instantiated
terms, % : for example generating say lists with at least two elements as
% \texttt{[1,2|Tail]}
without recurring to needed narrowing as in
LazySmallCheck~\cite{smallcheck}. On the more practical side, it would
be worthwhile to investigate \emph{random} generation, following the
ideas in~\cite{pltredexconstraintlogic,blanco19ppdp}.


Finally it makes sense to tie together the two threads of this paper
and provide a way of checking and elaborating proof evidence for
intuitionistic logic \emph{over} (inductively) defined atoms and
previously proven lemmata. This can go as far as FPC for inductive
proofs~\cite{blanco15wof}.

 \smallskip
 The source files mentioned in this paper are available at \url{https://github.com/proofcert/fpc-elpi}.\ednote{Or not. Fix this -am}

 % \begin{metanote}
%   Decided against a related work section: most is already discussed in the intro, the rest can be mentioned in passing --am
% \end{metanote}
% \subsection{Related work}
% \label{ssec:rel}

% \begin{itemize}
% \item Brief discussion/comparison with \texttt{auto} [done]
% \item Mention other papers by Enrico as applications of coq-elpi~\cite{coen19mscs,tassi19itp}\dots [done]
% \item Say we \textbf{do} not talk about Coq metaprogramming (Ltac, Mtac), do say that doing our to application in MetaCoq~\cite{sozeau2020metacoq} would be a disaster (reimplement unfication, backtracking, binders) [done]
% \end{itemize}

% \subsection{Future work}
% \label{ssec:fut}
%\todo{finish future work}
% Another current limitation of our PBT tactic is that it does not
% handle conversion within an inductive relation. One way to address
% this is to have the \emph{init} rule use Coq's unification rather than
% \lP's, via Coq-Elpi's \lsti{coq.unif-eq} hook.
%We plan to tackle this either at the Ltac level by co-routining it with simplification tactics and/or by adding rewriting features to our FPC system~\cite{ChihaniM16}.
% Mention \emph{Harpoon}, Beluga's new tactic language?

 
 % \todo{Link to the repo. Use \url{https://github.com/proofcert/fpc-elpi}, make it public andmove papers to parsifal}
 
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

% LocalWords:  Elpi simp LJF PBT LazySmallCheck Ltac Coq provers FPC
% LocalWords:  lemmata
