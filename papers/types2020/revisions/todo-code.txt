
-- code ---

0. in the paper we call dep_pbt with a fpc as input, but now it's just qheight.
On the other hand prolog.v is parametric with different clauses for solve (default qheight).
Making dep_pbt parametric needs some factoring of the preprocessing
[DONE: gen_dep_pbt.v Could use more factoring]

1. Conversion would help to allow computations inside inductive
definitions, so that we do not have to turn existing Coq code into
purely relation Prolog-like programs (eg. additions would be computed
by a primitive recursive function, not a relation). This way, the
dprolog/pbt tactic would mimic what (e)auto does, which
does a limited form of conversion by using simple apply
[note: auto is 534 line of inscrutable ML code with lots of heuristics
on how to use the default hint database]. auto incorporates conversion in goals
by adding eq_refl to the core database.

can we add conversion to the dependent kernel using unify-eq? Just
in the init rule?  Or in decide?
Should we move to a residuation
semantics to make equations explicit (not now)? And how does it
interact with Elpi's constraints? There might be something relevant in
the Dyckhoff-Legrange paper

[DONE: it's only in init and let us do prolog-computation modulo conversion, example:
  ordered ([1] ++ [2]), where ++ is primitive recursive def of append. However, we
  need to do this also for goals in interp/check [EASY]]


2. auto and hints. Trying to do everything that hints do in Coq is hopeless, but
at the moment we decide only on elements of Inductive and not for example on lemmas
(that would be <auto using <lemma>>). Coq-elpi provides a coq.elpi.accumulate
that helps modulate accumulation of lprolog files. Enrico says it can be used for hints.

[IN PROGRESS: we can do this for Hint Resolve. need to check more, possibly to use
cerficates to give priorities to hints. need to think if we can do also Rewrite and Unfold
by stating them, perhaps, as trivial lemma]

3. Repo reorganization to link to:

  - remove pbt and have only dep_pbt in list-query.v


Some usability desiderata

- What we print as counterexample is actually the instantiation of the
all the premises of query and hence hard to read: ex:

Goal forall x x' y: list nat,
append [0] x x' -> rev x y -> rev y x'.
Counterexample: (append [0] [] [0] /\ rev [] [])

- Things I do not understand with fpc generation:
 -- generation should be monotonic: if I find a cex at h,  I should find a larger one at h' > h. Instead, sometimes (ex ordered) raising the height I get the same cex, sometimes (aexp) I get
 a larger one, sometimes( aexp mutation M6) I loop (or exhaust the Bound) for one property
 (det of type) and instead  I get a larger cex for preservation:

height 2
Counterexample: (M6.has_type (tpred tzero) TBool /\ tpred tzero ===> tzero)

height 3
Counterexample: 
(M6.has_type (tif (tpred tzero) ttrue ttrue) TBool /\
 tif (tpred tzero) ttrue ttrue ===> tif tzero ttrue ttrue)

... and we are generating the same stuff, exp.


- Property  Goal forall e, progress e Mty.has_type step is clarly false (cex (tiszero ttrue))
but it runs out of steps???
