
\section{Appendix}
\label{sec:app}

In this appendix we list some definitions and pieces of code that we have  mentioned in the main paper.

\subsection{The vanilla meta-interpreter}


In Fig.~\ref{fig:interp} we report the encoding of the vanilla meta-interpreter used in
the testing phase of the \lsti{dep_pbt} tactic. Differently from Fig.~\ref{fig:kernel} we appeal, via quotations, to Coq's defined connectives. An \lsti{atomic} proposition is one defined \lsti{Inductive}ly. % The predicate \lsti{atomic} makes sure that \lsti{Atom} is \emph{not} a defined logical connective.

\begin{figure}
% \newcommand{\XXi}{\Pscr}
% \newcommand{\bc}[2]{\Pscr\Downarrow #1 \vdash #2}
% \[
% \infer{\XXi\vdash t = t}
% {%\eqExpert{\XXi}
% }
% \qquad
% \infer{\XXi\vdash \true}
% {%\trueExpert{\XXi}
% }
% \qquad
% \infer{\XXi\vdash G_1\vee G_2}
% {\XXi\vdash G_i%\qquad \orExpert{\XXi}{\XXi'}{i}
% }
% \qquad
% \infer{\XXi\vdash \exists x. G}
% {\XXi\vdash G[t/x]%\qquad \someExpert{\XXi}{\XXi'}{t}
% }
% \qquad 
% \infer{\XXi\vdash G_1\wedge G_2}
% {\XXi\vdash G_1\quad \XXi\vdash G_2%\quad \andExpert{\XXi}{\XXi_1}{\XXi_2}
% }
% \]
% \vskip -18pt
% \[
% \infer{\XXi\vdash A}
%       {\bc D A \quad D \in \Pscr}\qquad
%   \infer{\bc A A}{}{}\qquad
%   \infer{\bc{\forall x.\, D} A}{\bc{D[t/x]} A}{}\qquad
%   \infer{\bc{G\supset D} A}{\bc D A\quad \XXi\vdash G}{}
% \]
% In the judgment $\bc{D}{A}$, the variable $A$ ranges over only atomic
% formulas.
\lstinputlisting[basicstyle=\ttfamily,language=lprolog,linerange={interp-end}]{../code/dep-kernel.sig}
\lstinputlisting[basicstyle=\ttfamily,language=lprolog,linerange={interp-end}]{../code/dep-kernel-v2.mod}
\caption{Encoding in coq-elpi of the vanilla meta-interpreter}
\label{fig:interp}
%\lstinputlisting[linerange={sigs-end}]{code/dep-kernel.sig}
%\lstinputlisting[linerange={check-end}]{code/dep-kernel.mod}
%\caption{A dependent kernel for Coq terms.}
%\label{fig:kernel}
\end{figure}

\subsection{Semantics of the typed arithmetic language}
\label{ssec:types}

We list the rules for static and dynamic semantics of the language mentioned in section~\ref{ssec:dep_pbt} and related notions:
\begin{lstlisting}
Inductive has_type : tm -> typ -> Prop :=
   | T_Tru : has_type ttrue TBool
   | T_Fls : has_type tfalse TBool
    | T_Test : forall t1 t2 t3 T,
        has_type t1 TBool -> has_type t2 T -> has_type t3 T ->  has_type (tif  t1 t2 t3) T 
   | T_Zro : has_type tzero TNat
   | T_Scc : forall t1,  has_type t1 TNat -> has_type (tsucc t1) TNat
   | T_Prd : forall t1,  has_type t1 TNat -> has_type (tpred t1 ) TNat
   | T_Iszro : forall t1,  has_type t1 TNat ->  has_type (tiszero t1) TBool.
\end{lstlisting}

\begin{lstlisting}
Inductive nvalue : tm -> Prop :=
 | nv_zero : nvalue tzero
 | nv_succ : forall t, nvalue t -> nvalue (tsucc t).
Inductive bvalue : tm -> Prop :=
 | bv_t : bvalue ttrue
 | bv_f : bvalue tfalse. 
Reserved Notation "t1 '===>' t2" (at level 40).
Inductive step : tm -> tm -> Prop :=
   | ST_IfTrue : forall t1 t2,  (tif ttrue t1 t2) ===> t1
   | ST_IfFalse : forall t1 t2, (tif tfalse t1 t2) ===> t2
   | ST_If : forall t1 t1' t2 t3,
       t1 ===> t1' -> (tif t1 t2 t3) ===> (tif t1' t2 t3)
   | ST_Succ : forall t1 t1',
       t1 ===> t1' -> (tsucc t1) ===> (tsucc t1')
   | ST_PredZero : (tpred tzero) ===> tzero
   | ST_PredSucc : forall t1,
       nvalue t1 -> (tpred (tsucc t1)) ===> t1
   | ST_Pred : forall t1 t1',
       t1 ===> t1' -> (tpred t1) ===> (tpred t1')
   | ST_IszeroZero : (tiszero tzero) ===> ttrue
   | ST_IszeroSucc : forall t1,
        nvalue t1 ->  (tiszero (tsucc t1)) ===> tfalse
   | ST_Iszero : forall t1 t1',
       t1 ===> t1' -> (tiszero t1) ===> (tiszero t1')
 where "t1 '===>' t2" := (step t1 t2).
Inductive notstuck (e : tm) (Step : tm -> tm -> Prop) : Prop :=
  | pn : nvalue e  -> notstuck e Step
  | pb : bvalue e -> notstuck e Step
  | ps e' : Step e e' -> notstuck e Step.
\end{lstlisting}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

% LocalWords:  LJF Interp dep pbt coq elpi ly
