\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2019}
\input preamble
\input head

\title{Interfacing logic programming and Coq} % Other suggestions?
\titlerunning{Interfacing logic programming and Coq}

\begin{document}
\maketitle

\begin{abstract}
We do stuff
\end{abstract}

\section{Introduction}
\label{sec:intro}

Recently, C. Sacerdoti Coen and E. Tassi developed the ELPI
implementation \cite{dunchev15lpar} of \lP 
\cite{miller12proghol}.  More recently, Tassi has made ELPI available
as a plugin to the Coq proof assistant \cite{tassi18coqpl}.
%
This implementation of \lP extends earlier implementations in
primarily two directions.  First, ELPI adds a notion of contraints,
which makes it more expressive than, say, the Teyjus implementation of
\lP \cite{nadathur99cade}.  Second, the plugin version of ELPI comes
equip with an API for accessing the Coq environment and a quotation
and anti-quotation syntax allowing for Coq expressions to be mixed in
with \lP program elements.

ELPI provides a means for treating bindings and unification (of
structures containing bindings) that are convenient for various
meta-programming tasks in logic programming all things useful for
tactic programming in Coq (proof refinement).  For examples,
ELPI programmers are spared from dealing with low-level aspects of
representing bindings (e.g., De Bruijn indexes) while still having
clean and effective ways to manipulate binding structures.
%
In short, ELPI appears to be a useful meta-language for Coq
\cite{coen19mscs,tassi18coqpl,tassi19itp}.
%
In this paper, we outline two applications of the Coq plugin for ELPI
that support this claim.
%
With these examples, we shall illustrate that ELPI is a useful
meta-language not just because for its treatment of bindings and
syntactic structures in general but also because it is actually based
on a sound implementation of a higher-order intuitionistic logic.
%
Type inference is a well-known example of a meta-programming task for
which logic programming often provides immediate and elegant
implementations via the sound implementation of logic.
%
In this paper, we present two additional project in which an
implementation of proof search provides direct, elegant, and compact
implementations of meta-programming tasks.
%
Before we present these two examples, we first discuss the different
world views that the integration of ELPI and Coq focuses us to
confront. 

\section{Two cultures}

{\color{red} The rest of this section are just notes.}

These applications are not necessarily focused on the underlying
declarative nature of lambda Prolog.  For example, ELPI has various
extensions, such as ``spilling'' that are designed to make some
aspects of logic programming appear to be more functional.

In this paper, we limit our attention mostly to using lambda Prolog
for declarative processing: i.e., where logic plays a central role in
describing operations.  (Type checking is an example of such
processing, but we do not focus on type checking here).

Of course, being able to do declarative and not-so-declarative
operations within the same language makes that language all the more
useful.


  Given that lP and Coq are both examples of mixing the
  lambda-calculus with logic, it is important to understand their
  difference, something that can be very confusing.  Take the
  confusion around the term HOAS.  In some circles, this is a
  appropriate and sensible approach.  In other circles, it is
  semantically questionable.  But, in fact, this concept (using
  meta-level binding for object-level binding) plays our 
  differently depending on the meta language!

  The origin story to ML (Meta language) is that it supported
  LFC-style tactics and tacticals.  The strong typing of ML provided
  some guarantees: only theorems were ever given type thm.  But many
  steps of evolution have now taken place since then.  Isabelle's
  different approach to tactics.  Logic and proof theory, when used
  with Church's simple theory of types and Gentzen's sequent calculus,
  provides a far richer meta language: that provides an immediate and
  declarative treatment of bindings as well as for proof search
  (without the need of exception handling, etc).  [I'm making the case
  that FP is not a particularly natural framework for proof
  assistants.  Of course, lots of libraries have now been built in the
  FP style.]
  
  - Various dichotomies we find in this work.
    - proof theory vs type theory
    - logic programming vs functional programming
    - sequent calculus vs natural deduction

  - While both lambda Prolog and Coq are based on an amalgamation of
    $\lambda$-calculus and logic, these two languages take strikingly
    different approaches to bindings.  In lambda Prolog, bindings are
    syntactic and extensionality at any type is not available.  In
    Coq, however, higher-order typed quantification encodes
    extensional functions.  In lambda Prolog, (exists w. [lambda x. x]
    = [lambda x. w]) fails, no matter the type of w.  If this query
    was about functions, then this equation would be true when the
    type of w is a singleton.  But in lP, this is a query only about
    binding structures, and this fails to be proved since there is no
    capture-avoiding substitution (the only substitution supported by
    Church's STT) for w that makes the resulting two terms alpha,
    beta, eta convertible.  [Is this true in Coq?  What is equality
    here?]

  - On the proof theory side of this work, we use two different proof
    systems.

    - LJF, here we have undefined predicates, no induction
    - muMALL, were we have inductive definitions of predicates

    The Coq world provides for both of these kinds of predicate using
    Prop (corresponds to undefined) and Set (inductively defined).


\section{Elaboration of external proof certificates for the Coq
  kernel}

Follow the text in \cite{blanco20coq}.

\section{Property based testing for Coq}

\section{Conclusion}


% Not part of git repo.  Need to find a fix
\bibliography{../../../../repo/parsifal/papers/references/master} 

\end{document}
