\section{Revisiting property-based testing for Coq}

In a previous paper~\cite{blanco19ppdp}, we presented a
proof-theoretical reconstruction of property-based testing (PBT) of
relational specifications, adopting techniques from foundational proof
certificates to account for several features of these testing
paradigm: from various \emph{generation} strategies, to
\emph{shrinking} and fault localization.

Given the connection that \textsf{coq-elpi} offers between logic
programming and the internals of Coq, it is natural to extend the FPC-driven logic programming interpreter of the previous section to perform PBT of \lstinline{Inductive} types.

While nothing prevents us from porting all the features we discussed in~\cite{blanco19ppdp}, for the sake of this paper we will implement only FPC corresponding to different flavors \emph{exhaustive} generation and their combination, as adopted, e.g., in SmallCheck~\cite{smallcheck} and  $\alpha$Check~\cite{cheney_momigliano_2017}.

Of course, \textsf{QuickChick}~\cite{QChick}
(\url{https://softwarefoundations.cis.upenn.edu/qc-current}) is a
sophisticated and far-reaching PBT tool for Coq, which is based on a
different perspective: being a clone of Haskell's QuickCheck, it
emphasizes testing executable (read \emph{decidable)} specifications
with random generators. While current research~\cite{LampropoulosPP18} aims to increase automation, it is fair to say testing, in particular of  relational specifications, is still very labor intensive. We do not intend to compete with  \textsf{QuickChick}, but as we shall see, as far as \lsti{Inductive} definitions that corresponds to pure Horn programs, we can test them immediately without any decidability proof or configuration of generators and shrinkers.


\subsection{PBT as proof reconstruction}
\label{ssec:pbt-lp}

\begin{metanote}
  I'm just saying the bare minimum -am
\end{metanote}

 If we view  a property as a logical formula
\(\forall x [(\tau(x)\wedge P(x)) \supset Q(x)]\) where $\tau$ is a
typing predicate and $P$ and $Q$ are two other predicates defined
using Horn clause specifications, providing a counter-example
consists of  negating the property, and \emph{searching} for a proof of
\[
  \exists x [(\tau(x)\wedge P(x)) \wedge \neg Q(x)]
  \tag{*}\label{eq:full}
\]
%\(\exists x [(\tau(x)\land P(x)) \land \neg Q(x)]\).

In our current setting $P$ and $Q$ will be \lsti{Inductive} propositions, while $\tau$   are honest-to-goodness datatypes. We will treat the two quite differently, in so far as elements of those types will be \emph{generated}, while predicates will only be \emph{checked}. This distinction plays also a part in interpreting the negation sign.
%
When using a focused proof system for logic extended with fixed
points~\cite{baelde12tocl}, negation corresponds to the usual intutionistic interpretation.  % proofs of formulas such as
% \[
%   \exists x [(\tau(x)\wedge P(x)) \wedge \neg Q(x)]
%   \tag{*}\label{eq:full}
% \]
% are a single \emph{bipole}: that is, when reading a proof bottom up, a
% positive phase is followed on all its premises by a single negative
% phase that completes the proof.%
% In particular, the positive phase corresponds to the \emph{generation} phase
% and the negative phase corresponds to the \emph{testing} phase.
% %

% Instead of giving a full focused proof system of a logic including
% fixed points (since, as we will argue, that proof system will not, in
% fact, be needed to account for PBT ), we offer the following analogy.
% %
% Suppose that we are given a finite search tree and we are asked to
% prove that there is a secret located in one of the nodes of that
% tree.
% %
% A proof that we have found that secret can be taken to be a
% description of the path to that node from the root of the tree: that
% path can be seen as the proof certificate for that claim.
% %
% On the other hand, a proof that no node contains the secret is a
% rather different thing: here, one expects to use a blind and
% exhaustive search (via, say, depth-first or breath-first search) and
% that the result of that search never discovers the secret.
% %
% A proof of this fact requires \emph{no} external information: instead it
% requires a lot of computation involved with exploring the tree until
% exhaustion.
% %
% This follows the familiar pattern where the positive (generate) phase
% requires external information while the negative (testing) phase
% requires none.
%
However, for the sake of PBT, we can identify a proof certificate for
$(\ref{eq:full})$ with a proof certificate for
\[
  \exists x [\tau(x)\wedge P(x)].
  \tag{**}\label{eq:short}
\]
and will resort to negation-as-failure to check that the conclusion does not hold. This also means that we will not be able to return a Coq proof terms for the refutation of our property --- and neither does \textsf{QuickChick}, which runs at the OCaml level --- although we can return the witness for the existential.
% Such a certificate would contain the witness (closed) term $t$ for the
% existential quantifier and sufficient information to confirm that
% $P(t)$ can be proved (a proof of a typing judgment such as $\tau(t)$
% is usually trivial).
% Since a proof certificate for the existence-of-a-counterexample formula
% $(\ref{eq:full})$ can be taken as a proof certificate of
% $(\ref{eq:short})$, then we only need to consider proof certificates
% for Horn clause programs.
%
%Since the logic of Horn clauses is rather simple,
% We illustrate next what such proofs and proof certificates look like
% for the rather simple logic of Horn clauses.

\begin{metanote}
  TODO next
  \begin{itemize}
  \item The elpi dep-pbt tactic
  \item  the simple ordered example [DONE]
  \item a bit of details about the \texttt{aexp} example
  \end{itemize}
\end{metanote} 

\subsection{Implementing the tactic}
The working environment we expect when the tactic is invoked is a proof
environment, where the goal one is trying to prove is the property that the
specification should meet. This means that, after \lsti|intro| has been used to
introduce the relevant hypotheses, we will have a context consisting of
typing information for a bunch of variables that we should divide in two categories:
dependent variables, that appear also in the types of other variables, and non-dependent
variables, that don't appear elsewhere. Obviously, the two are the result of and \lsti|intro| on either
a dependent or a non-dependent product; in our setting, however, this division acquires an additional reading:
since specifications are encoded as pure Horn clauses, were no dependency is involved, non-dependent variables
simply tag the specification clauses whereas dependent variables represent the typing information for the data variables that 
the speficications use.

In order to generate a counterexample, we will need the user to specify which variables of the environment should
be used for generating data and which for executing the specification. In addition to this, the user should 
specify all the certificate information that will guide the data generation phase. The goal of the current environment will
directly provide the property for which we want to find a counterexample. Say we want to generate a counterexample for
some specification represented by \lsti|H1| and \lsti|H2| in the environment, and we want to generate the data for
some variables \lsti|v1| and \lsti|v2| with a height bounded to 10: the final call to the tactic will then 
look like:
\begin{lstlisting}
  elpi pbt 10 (H1 /\ H2) (v1) (v2)
\end{lstlisting}

In order to generate the query to the \lsti|check| predicate, some pre-processing is needed. In particular, we need to
turn the data variables into \lP logic variables when they appear inside a specification, and to generate querys to
\lsti|check| for each of these logic variables in association with the type of the data variable it corresponds to.
In order to code this preprocessing step, we leverage extensively \lP's higher order programming features. The substitutions
are handled with the technique of \lsti|copy| clauses.

Let us consider a  relational specification of ordered list:
\begin{lstlisting}
Inductive ordered : list nat -> Prop :=
| o_n : ordered []
| o_s : forall x : nat, ordered [x]
| o_c : forall (x y : nat), forall xs,  ordered xs  -> x <= y -> ordered (x:: y :: xs).     
\end{lstlisting}
%
A property we may wish to check before embarking in a formal proof is whether insertion preserves ordered-ness. Since we did slip in an error, our tactic reports a counter-example, e.g.,
\verb|(* Proof Term: [0, [0; 1; 0]] *)|:
\begin{lstlisting}
Conjecture ins_ord:  forall x xs rs, ordered xs -> insert x xs rs -> ordered rs.
intros x xs rs  Ho Hi.
elpi dep_pbt height 5 (Ho /\ Hi ) (x) (xs).
Abort.
\end{lstlisting}
In this query the tactic tests the hypotheses \lsti{Ho} and \lsti{Hi}
against data \lsti{x,xs} generated exhaustively up to proofs bounded by
at most $5$ unfoldings of the library \lsti{Inductive} definition of
\lsti{nat} and \lsti{list}.

Note that the same query in \textsf{QuickChick} would have required much more setup: if we wished to proceed relationally as above we would have had to provide a proof of decidability of the relevant notions. Were we to use functions, then we would have to implement a generator and shrinker for ordered lists.
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

% LocalWords:  Bedwyr bipole elpi QuickCheck OCaml TODO
