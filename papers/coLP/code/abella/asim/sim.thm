% proof that there are terms ground similar, but not similar

Specification "pcfl".


Close ty,tm.


Define tkle : tm -> tm -> ty -> prop by
tkle E F S:=
      {of E S} /\ {of F S} /\
       (forall v, {eval E v} -> {eval F v}).

% applicative simulation
CoDefine sim : tm -> tm -> ty -> prop by
sim  M1 M2 (arr S S') :=
	(forall M, {eval M1 (abs M)} -> 
	exists M' , {eval M2 (abs M')} /\ 
	(forall x, {of x S} -> sim  (M x) (M' x) S'));
sim N N' num :=
      	 ({eval N z} -> {eval N' z}) /\
	 (forall M, {eval N (s M)} ->
	 exists M', {eval N' (s M')} /\ sim M M' num);
sim L L' (list S) :=
      	 ({eval L nl} -> {eval L' nl}) /\
	 (forall H Tl, {eval L (cns H Tl)} ->
	 exists H' Tl', {eval L' (cns H' Tl')} /\ sim H H' S /\  sim Tl Tl' (list S)).

% ground simulation: arrow case is different
CoDefine gsim : tm -> tm -> ty -> prop by
gsim  M1 M2 (arr S S') :=
	(forall x, {of x S} -> gsim  (app M1 x) (app M2 x) S');
gsim N N' num :=
      	 ({eval N z} -> {eval N' z}) /\
	 (forall M, {eval N (s M)} ->
	 exists M', {eval N' (s M')} /\ gsim M M' num);
gsim L L' (list S) :=
      	 ({eval L nl} -> {eval L' nl}) /\
	 (forall H Tl, {eval L (cns H Tl)} ->
	 exists H' Tl', {eval L' (cns H' Tl')} /\ gsim H H' S /\  gsim Tl Tl' (list S)).

Theorem gsim_refl : forall M S, {is_ty S} -> gsim M M S.
coinduction.
intros.
case H1.
% arr
unfold.intros. backchain CH.
%num
unfold.
	intros.search.
	intros.
	exists M1.split.search.
	assert {is_ty num}.
	backchain CH.
%list
unfold.
	intros.search.
	intros.
	exists H.exists Tl.split.search.
	backchain CH.
	assert {is_ty (list S1)}.
			backchain CH.
%qed

Theorem kleene_gsim: forall M1 M2 S, tkle M1 M2 S -> {is_ty S} -> gsim M1 M2 S.
%coinduction .
intros.case H2.
% arr
skip. % not sure how this goes without an explicit simulation  
/*
unfold.intros.
  apply CH to H1 _.	  
case H1. 
case H6.
apply H6 to H5.
     exists M.split.search.
intros. backchain gsim_refl.
*/
% num
 unfold.intros.
case H1.apply H6 to H3.search.
intros.
case H1.apply H6 to H3.
     exists M.split.search.
        backchain gsim_refl.

% lst
 unfold.intros.
case H1.apply H7 to H4.search.
intros.
case H1.apply H7 to H4.
     exists H.exists Tl. split.search.
        backchain gsim_refl.
        backchain gsim_refl.

Theorem gsim_trans : forall M1 M2 M3 S, 
  gsim M1 M2 S -> gsim M2 M3 S -> gsim M1 M3 S.
coinduction. intros.
case H1.
%arr
unfold. intros.
case H2. apply H3 to H4.
 apply H5 to H4.
apply CH to H6 _. search.
% num
unfold.
	intros.
	case H2.
	apply H3 to H5.
	apply H6 to H8.search.

	intros.	
	case H2.
	apply H4 to H5.
	apply H7 to H8.
	exists M'1.split.search.
	apply CH to H9 H11 .search.
% lst
unfold.
	intros.
	case H2.
	apply H3 to H5.
	apply H6 to _.search.

	intros.	
	case H2.
	apply H4 to _.
	apply H7 to H8.
	exists H'1.exists Tl'1.split.search.
	apply CH to H9 _.search.
	apply CH to H10 _.search.
%qed.


Theorem no_eval_rec : forall V,
  {eval (rec x\ x) V} -> false.
induction on 1. intros. case H1.
  case H2.
 apply IH to H2.
 %qed
 
Theorem bot_kle_all: forall N S , {of N S} -> tkle (rec x\x) N S.
intros.
unfold.
	search. search.
intros.
apply no_eval_rec to H2.
%qed

Theorem bot_gsim_all: forall N T ,  {of N T} -> gsim (rec x\x) N T.
intros.
backchain kleene_gsim.
apply  bot_kle_all to H1. search.
 skip. % {of N T} ->  {is_ty T} % easy
%qed: 

% main result
Theorem cex_asim_gsim: exists M1 M2 T, gsim M1 M2 T /\ (sim M1 M2 T -> false).
exists (abs k\ (rec y\ y)).
exists (rec z\z).
exists (arr num num). split.

%gism
       unfold. intros.
       apply bot_gsim_all.
assert gsim  (app (abs (x\rec y\y)) x) (rec z\z) num .backchain kleene_gsim.
       unfold.
	search.
	search.
	intros.
	case H3. case H4. case H4. search.
assert gsim (rec z\z) (app (rec y\y) x) num. backchain bot_gsim_all.
backchain gsim_trans .
% asim
intros.
case H1.
assert {eval (abs (x\rec y\y)) (abs  (x\rec y\y))}.
apply H2 to H3.
apply no_eval_rec to H4.
%qed

/*

% from Leroy:

% usual CBN rules, but coinductively
% to be extended to full PCFL
CoDefine  coeval : tm -> tm -> prop by
    coeval (z) (z) ;
    coeval (abs R) (abs R) ;
    coeval (rec F) V := coeval (F (rec F)) V;
    coeval (app M N) V := exists R ,
        coeval M (abs R) /\ coeval (R N) V.

% divergence CBV 
CoDefine  divrg : tm  -> prop by
    divrg (rec F)  := divrg (F (rec F)) ;
    divrg (app M N)    := divrg M ;
    divrg (app M X)    := exists F , {eval M (abs F)}  /\ divrg (F X).



*/