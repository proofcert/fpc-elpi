%% counterexamples from Leroy-Grall's Coinductive big-step operational
%% semantics. IC, 2007

Kind    tm, ty, const, id, env, num    type.

Type    z    num.
Type    s    num -> num.

Type    zero, one    const.
Type    con          const -> tm.
Type    app          tm -> tm -> tm.
Type    fun ,rec         (tm -> tm) -> tm.
Type    i            ty.
Type    arr                      ty -> ty -> ty.
% ctx
Type    void    env.
Type    bind    tm ->  env -> env.


% standard CBN
Define inductive eval : tm -> tm -> prop by
    eval (con C) (con C);
    eval (fun R) (fun R);
    eval (rec F) C := eval (F (rec  F)) C;
    eval (app M N) V := exists R W,
        eval M (fun R) /\  eval (R N) V.
   

% applicative simulation -- typing assumtion to do
Define coinductive sim : tm -> tm -> ty -> prop by
sim  M1 M2 (arr S S') :=
	(forall M, eval M1 (fun M) -> 
	exists M' , eval M2 (fun M') /\ 
	(forall x, sim  (M x) (M' x) S'));
sim N N' i :=
      	 (eval N (con zero) -> eval N' (con zero)) /\
          (eval N (con one) -> eval N' (con one)).

% ground simulation: arrow case is different
Define coinductive gsim : tm -> tm -> ty -> prop by
gsim  M1 M2 (arr S S') :=
	(forall x, gsim  (app M1 x) (app M2 x) S');

gsim N N' i :=
      	 (eval N (con zero) -> eval N' (con zero)) /\
          (eval N (con one) -> eval N' (con one)).


% generators
Define mem : env -> tm -> prop by
    mem (bind A _) A ;
    mem (bind _ E) X := mem E X.

% well formed term (gen)
Define wt : num -> env -> tm -> prop by
    wt _ _ (con zero) ;
    wt _ _ (con one) ;
    wt _ E (A)              := mem E A ;
    wt (s N) E (app X Y)    := wt N E X /\ wt N E Y ;
	wt (s N) E (fun F)      := nabla x, wt N (bind x E) (F (x));
	    wt (s N) E (rec F)      := nabla x, wt N (bind x E) (F (x)).

% Well-formed terms with simple combined depth-size bounds
% For each constructor, consume a size unit and pass the remainder additively
Define wt'aux : num -> num -> num -> env -> tm -> prop by
    wt'aux _     (s NSIn) NSIn  _ (con zero) ;
    wt'aux _     (s NSIn) NSIn  _ (con one) ;
    wt'aux _     (s NSIn) NSIn  E (A)          := mem E A ;
    wt'aux (s N) (s NSIn) NSOut E (app X Y)    := wt'aux N NSIn NSMid E X /\ wt'aux N NSMid NSOut E Y ;
    wt'aux (s N) (s NSIn) NSOut E (rec F)      := nabla x, wt'aux N NSIn NSOut (bind x E) (F (x));
    wt'aux (s N) (s NSIn) NSOut E (fun F)      := nabla x, wt'aux N NSIn NSOut (bind x E) (F (x)).

Define triple : num -> num -> prop by
  triple z z ;
  triple (s N) (s (s (s M))) := triple N M.

% Take a based bound and use as height, triple as size
Define wt' : num -> env -> tm -> prop by
  wt' N E T := triple N N3 /\ wt'aux N N3 _ E T.

% omega is a term of height 3
#assert (wt  (s (s (s z))) void (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1)))).
#assert (wt  (s z) void (rec (x\x))).

% of course, this loops
# assert forall V, (eval (rec x\ x) V -> false).