fpc.def		porting to B of PPDP FPC architecture. check is parameterized
		over prog

fpc-ccs.def	encoding of finite ccs, simulation and trace equivalence

harness-fpc-ccs.thm	 some asserts about it

fpc-lam.def     encoding of lambda calculus with constants via coercions
		between i  tm: unwieldy and problematic wrt llambda unif

fpc-translam.def	 encoding of lambda calculus with constants via
			 a translation from i to tm

fpc-mono-lam.def	 encoding of lambda calculus with constants using
			the monotype i for both object and meta terms,
			 avoiding coercions and translations, but losing types


coeva.def		 the same but w/o FPC

==> the latter works, eg find cex in 3 secs with explicit generators,
but if diverges with fpc which should do exactly the same.









--- notes ----
TODO: this coercion business is costly wrt size: also

 the query returns

 check Gen (is_exp IE) Prog /\ trans IE E /\ coeval E ...


==> also : 0: LLambda unification prevented by i2l n1.

[alternatively: just go monotype and use only i:
coeval : i -> i -> prop]