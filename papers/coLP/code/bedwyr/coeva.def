%% counterexamples from Leroy-Grall's Coinductive big-step operational
%% semantics. IC, 2007

Kind    tm, ty, const, id, env, num    type.

Type    z    num.
Type    s    num -> num.

Type    zero, one    const.
Type    con          const -> tm.
Type    app          tm -> tm -> tm.
Type    fun          (tm -> tm) -> tm.
Type    i            ty.

% ctx
Type    void    env.
Type    bind    tm ->  env -> env.

Type    a,b,c,d    id.
% not used
Type    var        id -> tm.

% standard CBV
Define inductive eval : tm -> tm -> prop by
    eval (con C) (con C);
    eval (fun R) (fun R);
    eval (app M N) V := exists R W,
        eval M (fun R) /\ eval N W /\ eval (R W) V.
   
% usual CBV rules, but coinductively
Define coinductive coeval : tm -> tm -> prop by
    coeval (con C) (con C) ;
    coeval (fun R) (fun R) ;
    coeval (app M N) V := exists R W,
        coeval M (fun R) /\ coeval N W /\ coeval (R W) V.

% divergence CBV 
Define coinductive divrg : tm  -> prop by
    divrg (app M _)    := divrg M ;
	  divrg (app M X)    := exists V, eval M V /\ divrg X ;
    divrg (app M X)    := eval M (fun F) /\ eval X V /\ divrg (F V).

% generators
Define mem : env -> tm -> prop by
    mem (bind A _) A ;
    mem (bind _ E) X := mem E X.

% well formed term (gen)
Define wt : num -> env -> tm -> prop by
    wt _ _ (con zero) ;
    wt _ _ (con one) ;
    wt _ E (A)              := mem E A ;
    wt (s N) E (app X Y)    := wt N E X /\ wt N E Y ;
    wt (s N) E (fun F)      := nabla x, wt N (bind x E) (F (x)).

% Well-formed terms with simple combined depth-size bounds
% For each constructor, consume a size unit and pass the remainder multiplicatively
Define wt'aux : num -> num -> num -> env -> tm -> prop by
    wt'aux _     (s NSIn) NSIn  _ (con zero) ;
    wt'aux _     (s NSIn) NSIn  _ (con one) ;
    wt'aux _     (s NSIn) NSIn  E (A)          := mem E A ;
    wt'aux (s N) (s NSIn) NSOut E (app X Y)    := wt'aux N NSIn NSMid E X /\ wt'aux N NSMid NSOut E Y ;
    wt'aux (s N) (s NSIn) NSOut E (fun F)      := nabla x, wt'aux N NSIn NSOut (bind x E) (F (x)).

Define triple : num -> num -> prop by
  triple z z ;
  triple (s N) (s (s (s M))) := triple N M.

% Take a based bound and use as height, triple as size
Define wt' : num -> env -> tm -> prop by
  wt' N E T := triple N N3 /\ wt'aux N N3 _ E T.

% omega is a term of height 3
#assert (wt  (s (s (s z))) void (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1)))).
% omega conveges two different terms
#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con zero)).
#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con one)).

% failure of determinism in general. Page 20
#assert (wt (s (s (s z))) void M /\
	wt z void M1 /\ wt z void M2 /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false)).

/*
  + 2175ms
Found a solution:
 M2 = con one
 M1 = con zero
 M = app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1))

 */

% this is a term which diverges but does not co-evaluate- page 20
#assert (wt (s (s (s (s z)))) void M /\ divrg M /\ (forall V, coeval M V -> false)).

/*
  + 2074ms
Found a solution:
 M = app (con zero) (app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1)))

 */

 
 % Page 9: there are programs that neither evaluate nor diverge
% according to the rules above are said to “go wrong”. For instance,
% the program 0 0 goes wrong since neither 0 0 ⇒ v nor 0 0 ∞⇒ hold for
 % any v.

#assert (wt (s (s (s (s z)))) void M /\ (divrg M -> false) /\ (forall V, coeval M V -> false)).
/*
  + 1ms
Found a solution:
 M = app (con zero) (con zero)
*/

% % page 20: Moreover, there exists diverging terms that coevaluate to
% only one value. An     example is (λx.0) ω, which coevaluates to 0 but not
   %to any other term.


% to overcome the moding problem we generate the W -- TODO may have to generate the R as well
Define coinductive coeval_ev : num -> tm -> tm -> prop by
    coeval_ev I (con C) (con C) ;
    coeval_ev I (fun R) (fun R) ;
    coeval_ev I (app M N) V := exists R W,
        coeval_ev I M (fun R) /\ (wt I void W) /\ coeval_ev I N W /\ coeval_ev I (R W) V.

% with the right terms, OK
#assert  M = (app (fun x\ (con zero))  (app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1)))) /\ divrg M 
	/\ coeval_ev (s (s z)) M (con zero) /\ (forall V1,  coeval_ev (s (s z))  M V1 -> V = V1).

% 10724ms first time, then using table  2954ms
#assert (wt' (s (s (s (s z)))) void M /\ divrg M /\ wt (s z) void V
	/\ coeval_ev (s (s z)) M V /\ (forall V1,  coeval_ev z M V1 -> V = V1)).

% don't run this
#assert (wt (s (s (s (s z)))) void M /\ divrg M /\ wt (s z) void V
	/\ coeval_ev (s (s z)) M V /\ (forall V1,  coeval_ev z M V1 -> V = V1)).
/* M = (app (fun x\ (con zero))  (app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1))))


% RB: The term of interest (M, above) can be found in a reasonable time by wt'.
% However, `coeval M (con zero)`, for the above M, seems to loop.

  %AM: yes  coeval (λx.0) ω (con zero) loops because it needs mode + +, but
  % we have the subgoal exists V, coeval ω V that loops.
  % see the abella proof in sim.thm
# assert (wt (s (s (s (s z)))) void M /\ divrg M /\ wt (s z) void V
	/\ coeval M V /\ (forall V1,  coeval M V1 -> V = V1)).

# assert (wt' (s (s (s (s z)))) void M /\ divrg M /\ wt (s z) void V
	/\ coeval M V /\ (forall V1,  coeval M V1 -> V = V1)).

 (wt (s (s (s z))) void M /\ M1 = con zero /\ M2 = con one /\ 
	 coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false)).
# assert  M = (app (fun x\ (con zero))  (app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1)))) /\ divrg M /\ 
	/\ coeval M (con zero) /\ (forall V1,  coeval M V1 -> V = V1)).
*/