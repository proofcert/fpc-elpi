%% failure of determinism in coevaluation
%% using monotype i for meta and object terms
#include "fpc.def".

Kind    const, env, trenv    type.

Type    zero,one                     const.
Type    con                          const -> i.
Type    app                          i -> i -> i.
Type    fun                          (i -> i) -> i.
Type    icon                         const -> i.
Type    iapp                         i -> i -> i.
Type    ifun                         (i -> i) -> i.

% ctx
Type    void    env.
Type    bind    i -> env -> env.

% usual CBV rules
Define inductive eval : i -> i -> prop by
    eval (con C) (con C) ;
    eval (fun R) (fun R) ;
    eval (app M N) V := exists R W,
        eval M (fun R) /\ eval N W /\ eval (R W) V.
   
% usual CBV rules, but coinductively
Define coinductive coeval : i -> i -> prop by
    coeval (con C) (con C) ;
    coeval (fun R) (fun R) ;
    coeval (app M N) V := exists R W,
        coeval M (fun R) /\ coeval N W /\ coeval (R W) V.

% divergence CBV (see Leroy)
Define coinductive divrg : i -> prop by
    divrg (app M _)    := divrg M ;
	  divrg (app M X)    := exists V, eval M V /\ divrg X ;
	  divrg (app M X)    := eval M (fun F) /\ eval X V /\ divrg (F V).

% gen
Define mem : env -> i -> prop by
    mem (bind A _) A ;
    mem (bind _ E) X  := mem E X.

Type    is_exp    env -> i -> oo.

Define prog_lam : oo -> oo -> prop by
    prog_lam (is_exp _ (con zero)) (tt) ;
    prog_lam (is_exp _ (con one)) (tt) ;
    prog_lam (is_exp Ctx (app Exp1 Exp2))
             (and (is_exp Ctx Exp1) (is_exp Ctx Exp2)) ;
	  prog_lam (is_exp Ctx (fun ExpX)) 
	           (all x\ is_exp (bind x Ctx) (ExpX x)) ; % x : i
	  prog_lam (is_exp Ctx X) (tt) := mem Ctx X.

% Some more discriminating generators for example #4

% Find terms with up to a given "function depth"
% This finds our man, though quite slowly (depth 1, triple bound 5, 1040672ms)
Type    is_exp_dfun    nt -> env -> i -> oo.

Define prog_lam_dfun : oo -> oo -> prop by
    prog_lam_dfun (is_exp_dfun _ _ (con zero)) (tt) ;
    prog_lam_dfun (is_exp_dfun _ _ (con one)) (tt) ;
    prog_lam_dfun (is_exp_dfun N Ctx (app Exp1 Exp2))
                  (and (is_exp_dfun N Ctx Exp1) (is_exp_dfun N Ctx Exp2)) ;
	  prog_lam_dfun (is_exp_dfun (s N) Ctx (fun ExpX)) 
	                (all x\ is_exp_dfun N (bind x Ctx) (ExpX x)) ; % x : i
	  prog_lam_dfun (is_exp_dfun _ Ctx X) (tt) := mem Ctx X.

% Find terms with up to a given "function count"
% This also finds the term of interest (3 functions, triple bound 5, 1204662ms)
% Of course both bounds could be combined
Type    is_exp_nfun    nt -> nt -> env -> i -> oo.

Define prog_lam_nfun : oo -> oo -> prop by
    prog_lam_nfun (is_exp_nfun NIn NIn _ (con zero)) (tt) ;
    prog_lam_nfun (is_exp_nfun NIn NIn _ (con one)) (tt) ;
    prog_lam_nfun (is_exp_nfun NIn NOut Ctx (app Exp1 Exp2))
                  (and (is_exp_nfun NIn NMid Ctx Exp1) (is_exp_nfun NMid NOut Ctx Exp2)) ;
	  prog_lam_nfun (is_exp_nfun (s NIn) NOut Ctx (fun ExpX)) 
	                (all x\ is_exp_nfun NIn NOut (bind x Ctx) (ExpX x)) ; % x : i
	  prog_lam_nfun (is_exp_nfun NIn NIn Ctx X) (tt) := mem Ctx X.

% omega is a term of height 3
%#assert (wt  (s (s (s z))) void (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1)))).
#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con zero)).
#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con one)).

% RB: A refinement of the first property that runs in a reasonable time. The
% primary difference with respect to coeval_non_det is that search depth is
% allowed to vary across terms. The basic idea behind coeval_non_det works, it
% is just less efficient than the version in coeva. The combinatorial explosion
% is one of the factors that contribute to its unwieldiness, the other are the
% inefficiencies introduced by the encoding (in my laptop, getting to the larger
% term in isolation is an order of magnitude slower here and requires depth 4
% instead of 3 in coeva.
Define coeval_non_det' : cert -> cert -> i -> i -> i -> prop by
       coeval_non_det' GenBig GenSmall M M1 M2 :=
  % Generate the "large" base term
	check GenBig (is_exp void M) prog_lam /\
  % Generate the two "small" evaluation results
  % Combination can be done at the object or meta level
	check GenSmall (is_exp void M1) prog_lam /\
	check GenSmall (is_exp void M2) prog_lam /\
  % Perform checks
  % It would be more efficient to check for inequality at the head
  coeval M M1 /\ coeval M M2 /\ (M1 = M2 -> false).

#assert coeval_non_det' (qheight (s (s (s (s z))))) (qheight (s z)) M M1 M2.

% OK in principle, just terribly slow
Define coeval_non_det : cert -> i -> i -> i -> prop by
       coeval_non_det Gen M M1 M2 := 
	check Gen (and (is_exp void M)
	(and (is_exp void M1)  (is_exp void M2))) prog_lam
       /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false).

% cheating and passing omega
Define coeval_non_detH : cert ->  i -> i -> prop by
       coeval_non_detH Gen M1 M2 :=
	M = app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1)) /\ 
	check Gen 
	(and (is_exp void M1)  (is_exp void M2)) prog_lam
       /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false).


Define div_not_coeval : cert -> i -> prop by
        div_not_coeval Gen M := 
	check Gen (is_exp void M) prog_lam
	/\ divrg M /\ (forall V, coeval M V -> false).

% RB: This one works, but also needs one more height with respect to coeva.
% Getting to generate the desired term is again one order of magnitude slower
% in this version, although the overall result is not as slower.
#assert div_not_coeval (qheight (s (s (s (s (s z)))))) M.

Define not_div_not_coeval : cert -> i -> prop by
    not_div_not_coeval Gen M := 
	      check Gen (is_exp void M) prog_lam /\
        (divrg M -> false) /\ (forall V, coeval M V -> false).

#assert not_div_not_coeval (qheight (s (s z))) M.
