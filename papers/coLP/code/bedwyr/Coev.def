%% counterexamples from Leroy-Grall's Coinductive big-step operational
%% semantics. IC, 2007 W/O constants

Kind    tm, ty, const, id, env, num    type.

Type    z    num.
Type    s    num -> num.

Type    app          tm -> tm -> tm.
Type    fun          (tm -> tm) -> tm.
Type    i            ty.

% ctx
Type    void    env.
Type    bind    tm ->  env -> env.

Type    a,b,c,d    id.


% standard CBV
Define inductive eval : tm -> tm -> prop by
    eval (fun R) (fun R);
    eval (app M N) V := exists R W,
        eval M (fun R) /\ eval N W /\ eval (R W) V.
   
% usual CBV rules, but coinductively
Define coinductive coeval : tm -> tm -> prop by
    coeval (fun R) (fun R) ;
    coeval (app M N) V := exists R W,
        coeval M (fun R) /\ coeval N W /\ coeval (R W) V.

% divergence CBV 
Define coinductive divrg : tm  -> prop by
    divrg (app M _)    := divrg M ;
	  divrg (app M X)    := exists V, eval M V /\ divrg X ;
    divrg (app M X)    := eval M (fun F) /\ eval X V /\ divrg (F V).

% generators
Define mem : env -> tm -> prop by
    mem (bind A _) A ;
    mem (bind _ E) X := mem E X.

% well formed term (gen)
Define wt : num -> env -> tm -> prop by
    wt _ E (A)              := mem E A ;
    wt (s N) E (app X Y)    := wt N E X /\ wt N E Y ;
    wt (s N) E (fun F)      := nabla x, wt N (bind x E) (F (x)).

Define qsize : num -> num -> env -> tm -> prop by
    qsize N N E (A)              := mem E A ;
    qsize N M E (app X Y)    := qsize N N1 E X /\ qsize N1 M E Y ;
    qsize (s N) M E (fun F)      := nabla x, qsize N M (bind x E) (F (x)).


% Well-formed terms with simple combined depth-size bounds
% For each constructor, consume a size unit and pass the remainder multiplicatively
Define wt'aux : num -> num -> num -> env -> tm -> prop by
    wt'aux _     (s NSIn) NSIn  E (A)          := mem E A ;
    wt'aux (s N) (s NSIn) NSOut E (app X Y)    := wt'aux N NSIn NSMid E X /\ wt'aux N NSMid NSOut E Y ;
    wt'aux (s N) (s NSIn) NSOut E (fun F)      := nabla x, wt'aux N NSIn NSOut (bind x E) (F (x)).

Define triple : num -> num -> prop by
  triple z z ;
  triple (s N) (s (s (s M))) := triple N M.

% Take a based bound and use as height, triple as size
Define wt' : num -> env -> tm -> prop by
  wt' N E T := triple N N3 /\ wt'aux N N3 _ E T.

% omega is a term of height 3
#assert (wt  (s (s (s z))) void (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1)))).
% omega conveges two different terms
%#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con zero)).
%#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con one)).

% failure of determinism in general. Page 20
#assert (wt (s (s (s z))) void M /\
	wt (s z) void M1 /\ wt (s (s z)) void M2 /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false)).

/*
  + 45ms

Found a solution:
 M2 = app (fun (x1\ x1)) (fun (x1\ x1))
 M1 = fun (x1\ x1)
 M = app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1))

  */
%% too long, why?
#assert (M = app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1)) /\ qsize (s (s z)) z void M /\
	qsize (s z) z void M1 /\ qsize (s (s z)) z void M2 /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false)).

% this is a term which diverges but does not co-evaluate- page 20
#assert (wt (s (s (s (s z)))) void M /\ divrg M /\ (forall V, coeval M V -> false)).

/*
    without constants, does not find anything
    
  + 2074ms
Found a solution:
 M = app (con zero) (app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1)))

 */

 
 % Page 9: there are programs that neither evaluate nor diverge
% according to the rules above are said to “go wrong”. For instance,
% the program 0 0 goes wrong since neither 0 0 ⇒ v nor 0 0 ∞⇒ hold for
 % any v.

#assert (wt (s (s (s (s z)))) void M /\ (divrg M -> false) /\ (forall V, coeval M V -> false)).
/*
  NO RESULT
  + 1ms
Found a solution:
 M = app (con zero) (con zero)
*/

% % page 20: Moreover, there exists diverging terms that coevaluate to
% only one value. An     example is (λx.0) ω, which coevaluates to 0 but not
   %to any other term.


% to overcome the moding problem we generate the W -- TODO may have to generate the R as well
Define coinductive coeval_ev : num -> tm -> tm -> prop by
      coeval_ev I (fun R) (fun R) ;
    coeval_ev I (app M N) V := exists R W,
        coeval_ev I M (fun R) /\ (wt I void W) /\ coeval_ev I N W /\ coeval_ev I (R W) V.

% with the right terms, OK
%#assert  M = (app (fun x\ (con zero))  (app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1)))) /\ divrg M 
%	/\ coeval_ev (s (s z)) M (con zero) /\ (forall V1,  coeval_ev (s (s z))  M V1 -> V = V1).

% 10724ms first time, then using table  2954ms
#assert (wt' (s (s (s (s z)))) void M /\ divrg M /\ wt (s z) void V
	/\ coeval_ev (s (s z)) M V /\ (forall V1,  coeval_ev z M V1 -> V = V1)).

% % don't run this
% #assert (wt (s (s (s (s z)))) void M /\ divrg M /\ wt (s z) void V
% 	/\ coeval_ev (s (s z)) M V /\ (forall V1,  coeval_ev z M V1 -> V = V1)).
% /* M = (app (fun x\ (con zero))  (app (fun (x1\ app x1 x1)) (fun (x1\ app x1 x1))))


