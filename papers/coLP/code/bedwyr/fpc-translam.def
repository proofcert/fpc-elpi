%% failure of determinism in coevaluation
%% translation, no coercion
#include "fpc.def".

Kind    tm, ty, const,  env ,trenv      type.

Type    zero,one              const.
Type    con               const -> tm.
Type    app                    tm -> tm -> tm.
Type    fun                    (tm -> tm) -> tm.
Type    icon               const -> i.
Type    iapp                    i -> i -> i.
Type    ifun                    (i -> i) -> i.


% ctx
Type    void    env.
Type    bind    i ->  env -> env.

% translation ctx

Type    tvoid    trenv.
Type    tbind    i -> tm ->  trenv -> trenv.

Define tmem : trenv -> i -> tm ->  prop
       by tmem (tbind A T _) A T
    ;  tmem (tbind _ _ TE) X Y  := tmem TE X Y .


Define i2tm : trenv -> i -> tm -> prop by

       i2tm _ (icon C) (con C);
       i2tm TE (iapp I1 I2) (app T1 T2) := i2tm TE I1 T1 /\ i2tm TE I2 T2;
	i2tm TE (ifun I) (fun T) := nabla x y, i2tm (tbind x y TE) (I x) (T y);
	i2tm TE I T := tmem TE I T.


% usual CBV rules
Define inductive  eval : tm -> tm -> prop by
     eval (con C) (con C);
     eval (fun R) (fun R);
     eval (app M N) V := exists R W, eval M (fun R) /\
        eval N W /\ eval (R W) V.
   
% usual CBV rules, but coinductively
Define coinductive  coeval : tm -> tm -> prop by
     coeval (con C) (con C);
     coeval (fun R) (fun R);
     coeval (app M N) V := exists R W, coeval M (fun R) /\
        coeval N W /\ coeval (R W) V.

% divergence CBV (see Leroy)
Define coinductive divrg : tm  -> prop by
       divrg (app M _)            := divrg M ;
	divrg (app M X)            := exists V, eval M V /\ divrg X ;
	divrg (app M X)            := eval M (fun F) /\ eval X V /\ divrg (F V) .

% gen
 Define mem : env -> i ->  prop
 by mem (bind A  _) A
    ;  mem (bind _  E) X  := mem E X .

Type is_exp env ->  i -> oo.
Define prog_lam :  oo -> oo -> prop by
       prog_lam (is_exp _ (icon zero)) (tt);
       prog_lam (is_exp _ (icon one)) (tt);
       prog_lam (is_exp Ctx (iapp Exp1 Exp2))
          (and (is_exp Ctx Exp1) (is_exp Ctx Exp2));
	prog_lam (is_exp Ctx (ifun ExpX)) 
	(all x \ is_exp (bind x Ctx) (ExpX x)); % x : i
	prog_lam (is_exp Ctx X) (tt) := mem Ctx X.


% % well formed term (gen)
% Define wt : num -> env -> tm -> prop by
%        wt _ _ (con zero);
%        wt _ _ (con one);
%        wt _ E ( A)             := mem E A ;
%        wt (s N) E (app X Y)           := wt N E X  /\ wt N E Y ;
%   wt (s N) E (fun F)  := nabla x, wt N (bind x  E) (F ( x)).

% omega is a term of height 3
%#assert (wt  (s (s (s z))) void (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1)))).
#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con zero)).
#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con one)).


% #assert (wt (s (s (s z))) void M /\
% 	wt z void M1 /\ wt z void M2 /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false)).

Define coeval_non_det : cert -> tm -> tm -> tm -> prop by
       coeval_non_det Gen M M1 M2 := 
	exists I I1 I2, check Gen (and  (is_exp void I)
	(and (is_exp void I1)  (is_exp void I2))) prog_lam
	/\ i2tm tvoid I M /\ i2tm tvoid I1 M1 /\ i2tm tvoid I2 M2
       /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false).

% cheating and passing omega
Define coeval_non_detH : cert -> tm -> tm -> tm -> prop by
       coeval_non_detH Gen M M1 M2 :=
	I = iapp (ifun (x1\ iapp x1 x1)) (ifun (x1\ iapp x1 x1)) /\ 
	exists I1 I2, check Gen 
	(and (is_exp void I1)  (is_exp void I2)) prog_lam
	/\ i2tm tvoid I M /\ i2tm tvoid I1 M1 /\ i2tm tvoid I2 M2
       /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false).


Define div_not_coeval : cert -> tm -> prop by
        div_not_coeval Gen M := 
	exists I, check Gen (is_exp void I) prog_lam
	/\ i2tm tvoid I M /\  divrg M /\ (  forall V, coeval M V -> false).


%#assert M = (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1)))) /\
%	M1 = (con zero) /\ coeval_non_det (qheight (s (s (s (s z))))) M M1 M2.

/*#assert I = iapp (ifun (x1\ iapp x1 x1)) (ifun (x1\ iapp x1 x1))
	/\ i2tm tvoid I M /\
	/\ coeval_non_det (qheight (s (s (s (s z))))) M M1 M2.
*/
% % P = app (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (app (con zero) (con zero)) /\  wt (s (s (s (s z)))) void P /\ divrg P.
% #assert (wt (s (s (s (s z)))) void M /\ wt (( z)) void V /\
% 	divrg M /\ (  coeval M V -> false)).



% 
% check (qheight N)  (is_exp void (iapp (ifun (x1\ iapp x1 x1)) (ifun (x1\ iapp x1 x1)))) prog_lam.
   %  N = s (s (s (s H0)))
   /*
I = iapp (ifun (x1\ iapp x1 x1)) (ifun (x1\ iapp x1 x1))
  /\ i2tm tvoid I M
  */