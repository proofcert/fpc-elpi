%% failure of determinism in coevaluation

#include "fpc.def".

Kind    tm, ty, const, id, env       type.


% coercions among object and meta terms
Type l2i   tm -> i.
Type t2i   ty -> i .    
Type i2l  i -> tm.
Type i2t  i -> ty.


Type    zero,one              const.
Type    con               const -> tm.
Type    app                    tm -> tm -> tm.
Type    fun                    (tm -> tm) -> tm.
Type    i               ty.

% ctx
Type    void    env.
Type    bind    i ->  env -> env.

% Type    a,b,c,d     id.
% not used
Type var id -> tm.

% usual CBV rules
Define inductive  eval : tm -> tm -> prop by
     eval (con C) (con C);
     eval (fun R) (fun R);
     eval (app M N) V := exists R W, eval M (fun R) /\
        eval N W /\ eval (R W) V.
   
% usual CBV rules, but coinductively
Define coinductive  coeval : tm -> tm -> prop by
     coeval (con C) (con C);
     coeval (fun R) (fun R);
     coeval (app M N) V := exists R W, coeval M (fun R) /\
        coeval N W /\ coeval (R W) V.

% divergence CBV (see Leroy)
Define coinductive divrg : tm  -> prop by
       divrg (app M _)            := divrg M ;
	divrg (app M X)            := exists V, eval M V /\ divrg X ;
	divrg (app M X)            := eval M (fun F) /\ eval X V /\ divrg (F V) .

% gen
 Define mem : env -> i ->  prop
 by mem (bind A  _) A
    ;  mem (bind _  E) X  := mem E X .

Type is_exp env ->  i -> oo.
Define prog_lam :  oo -> oo -> prop by
       prog_lam (is_exp _ (l2i (con zero))) (tt);
       prog_lam (is_exp _ (l2i (con one))) (tt);
       prog_lam (is_exp Ctx (l2i (app Exp1 Exp2)))
          (and (is_exp Ctx (l2i Exp1)) (is_exp Ctx (l2i Exp2)));
	prog_lam (is_exp Ctx (l2i (fun ExpX))) 
	(all x \ is_exp (bind x Ctx) (l2i (ExpX (i2l x)))); % x : i
	prog_lam (is_exp Ctx X) (tt) := mem Ctx X.


% % well formed term (gen)
% Define wt : num -> env -> tm -> prop by
%        wt _ _ (con zero);
%        wt _ _ (con one);
%        wt _ E ( A)             := mem E A ;
%        wt (s N) E (app X Y)           := wt N E X  /\ wt N E Y ;
%   wt (s N) E (fun F)  := nabla x, wt N (bind x  E) (F ( x)).

% omega is a term of height 3
%#assert (wt  (s (s (s z))) void (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1)))).
#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con zero)).
#assert (coeval (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (con one)).


% #assert (wt (s (s (s z))) void M /\
% 	wt z void M1 /\ wt z void M2 /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false)).

Define coeval_non_det : cert -> tm -> tm -> tm -> prop by
       coeval_non_det Gen M M1 M2 := 
	check Gen (and  (is_exp void (l2i M))
	          (and (is_exp void (l2i M1))  (is_exp void (l2i M2)))) prog_lam 
       /\ coeval M M1 /\ coeval M M2 /\ (  M1 = M2 -> false).

#assert coeval_non_det (qheight (s (s (s (s z))))) M M1 M2.

% % P = app (app (fun (x1\app x1 x1)) (fun (x1\app x1 x1))) (app (con zero) (con zero)) /\  wt (s (s (s (s z)))) void P /\ divrg P.
% #assert (wt (s (s (s (s z)))) void M /\ wt (( z)) void V /\
% 	divrg M /\ (  coeval M V -> false)).



