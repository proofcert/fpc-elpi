% Porting the simple FPC PPDP architecture to Bedwyr

% logic

Kind i type.  
Kind oo        type.
Type tt        oo.
Type and, or   oo  -> oo -> oo.
Type some,all      (i -> oo) -> oo.
Type eq        i -> i  -> oo.

% Certificates

Kind nt     type.
Type z    nt.
Type s    nt -> nt.
Kind cert          type.
Kind choice        type.
Type left, right   choice.

Type   qheight   nt -> cert.
Type   qsize     nt -> nt -> cert.

Kind max     type.
Type max     max     -> cert.
Type binary  max    -> max -> max.
Type choose  choice -> max -> max.
Type term    i      -> max -> max.
Type empty   max.

Type   c    cert ->  cert ->  cert.
%infixr <c>     5.

%% clerks and experts

Define eqE :     cert -> prop by
       eqE     (qheight _);
       eqE     (qsize In In);
       eqE (c A B) := eqE A /\  eqE B.

Define ttE :     cert -> prop by
       ttE     (qheight _);
       ttE     (qsize In In);
       ttE (c A B) := ttE A /\  ttE B.

Define orE :     cert -> cert -> choice -> prop by
       orE     (qheight H) (qheight H) _ ;
       orE     (qsize In Out) (qsize In Out) _ ;
       orE (c A B) (c C D) E := orE A C E /\  orE B D E.

Define andE :     cert -> cert -> cert -> prop by
       andE     (qheight H) (qheight H) (qheight H) ;
       andE     (qsize In Out) (qsize In Mid) (qsize Mid Out);
       andE (c A B) (c C D) (c E F) := andE A C E /\  andE B D F.

Define someE :     cert -> cert -> i -> prop by
       someE     (qheight H) (qheight H) _ ;
       someE     (qsize In Out) (qsize In Out) _;
       someE (c A B) (c C D) T := someE A C T /\  someE B D T.

Define unfoldE :     cert -> cert  -> prop by
       unfoldE (qheight (s H)) (qheight H);
       unfoldE (qsize (s In) Out) (qsize In Out);
       unfoldE (c A B) (c C D) := unfoldE A C /\ unfoldE B D.
%%%%% end generic part %%%%%%%%%

% the kernel depends on prog and I  pass it as
% as predicate

Define   check :    cert -> oo -> ( oo -> oo -> prop) -> prop by

check Cert tt P         := ttE Cert;
check Cert (eq T T) P   := eqE Cert;
check Cert (and G1 G2) P :=
   andE Cert Cert1 Cert2 /\ 
   check Cert1 G1 P /\  check Cert2 G2 P;
check Cert (or G1 G2) P :=
  exists LR Cert', orE Cert Cert' LR /\  
   ((LR = left /\   check Cert' G1 P) \/
   (LR = right /\  check Cert' G2 P));

check Cert (some G) P := 
    exists CertQ T, someE Cert Cert1 T /\ 
    check Cert1 (G T) P;

check Cert (all G) P :=
           nabla x, check Cert (G x) P;
check Cert A Prog :=
	exists G Cert', unfoldE Cert Cert' /\  
      Prog A G /\  check Cert' G Prog.
