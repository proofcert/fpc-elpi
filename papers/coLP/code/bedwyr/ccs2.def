%% Encoding of CCS from Abella's library ccs_two_level ported

%% 2. there are p,q such that p < q and q < p, but not p ~ q


Kind    proc, act,num      type.

Type z num.
Type s num -> num.

Type    a,  b, tau         act .
Type    bar            act -> act .

Type    null           proc.
Type    out            act -> proc -> proc.
Type    plus, par      proc -> proc -> proc.
Type    mu             (proc -> proc) -> proc.


%Type    

Define comp : act -> act -> prop by
comp A (bar A);
comp (bar A) A.

Define step :          proc -> act -> proc -> prop by
step (out A P) A P;
step (plus P Q) A P1 := step P A P1;
step (plus P Q) A Q1 := step Q A Q1;
step (par P Q) A (par P1 Q) := step P A P1;
step (par P Q) A (par P Q1) := step Q A Q1;
step (mu P) A Q := step (P (mu P)) A Q;
step (par P Q) tau (par P1 Q1) :=
  exists A B, comp A B /\ step P A P1 /\ step Q A Q1.

Define is_act : act -> prop by
is_act  a ; is_act b ; is_act tau.
%; is_act (bar A) := is_act A. %removed just for this examples (ow needs boubds(

Define is_proc :          num -> proc  -> prop by
is_proc _ null;
is_proc (s N) (out A P) := is_act A /\ is_proc N P;
is_proc (s N) (plus P Q) := is_proc N P /\ is_proc N Q;
is_proc (s N) (par P Q) := is_proc N P /\ is_proc N Q.
% is_proc (mu P)  := is_proc (P (mu P)) . % readd

Define peq : proc -> proc -> prop by
       peq P Q := P = Q.
% we cheat and add reflexivity
Define coinductive sim : proc -> proc -> prop by
%       sim P Q := peq P  Q;
	sim P Q :=
    forall A P1,  step P A P1  -> exists Q1,  step Q A Q1  /\ sim P1 Q1.


Define coinductive bisim : proc -> proc -> prop by
  bisim P Q :=
    (forall A P1, step P A P1 -> exists Q1, step Q A Q1 /\ bisim P1 Q1) /\
    (forall A Q1, step Q A Q1 -> exists P1, step P A P1 /\ bisim P1 Q1).



Define inductive n_bisim : proc -> proc -> prop by
  n_bisim P Q :=
	(exists A P1, step P A P1 /\ forall Q1, step Q A Q1 -> n_bisim P1 Q1) \/
	(exists A Q1, step Q A Q1 /\ forall P1, step P A P1 -> n_bisim Q1 P1).
% P is (plus (out a (out b null)) (out a null)).  s (s (s H))
% Q is exists (out a (out b null)).
%%% does not need reflexivity?
%  P = plus (out a (out b null)) (out a null) /\ Q = (out a (out b null)) /\ sim P Q /\ sim Q P


% still, This formula cannot be handled by the left prover!
% #assert (P = plus (out a (out b null)) (out a null) /\ Q = (out a (out b null)) /\ sim P Q /\ sim Q P /\ (bisim P Q -> false)).
#assert (P = plus (out a (out b null)) (out a null) /\ Q = (out a (out b null)) /\ sim P Q /\ sim Q P /\ (n_bisim P Q)).

%  (P = plus (out a (out b null)) (out a null) /\ Q = (out a (out b null)) /\ sim P Q /\ sim Q P /\ (bisim P Q -> false))


Define cex_snb : num -> proc -> proc -> prop by
       cex_snb N P Q :=
	 is_proc N P /\ is_proc N Q /\ sim P Q /\ sim Q P
 /\ (bisim P Q -> false).

% 
#assert ((N = (s (s (s z))) /\ is_proc N P /\ is_proc N Q /\ sim P Q /\ sim Q P
 /\ (n_bisim P Q))).
 % P = ab + a

% Q = ab
#assert (N = (s (s (s z))) /\ is_proc N P
	/\ (n_bisim (par P P) P)).
%  P = out a null