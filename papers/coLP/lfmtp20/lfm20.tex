\RequirePackage[utf8]{inputenc}
\RequirePackage[T1]{fontenc}
\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{LFMTP 2020}
\usepackage{url,xcolor}
\usepackage{listings}
\usepackage{letltxmacro}
\input{../types20/listing-macros}  % Use to get better highlighing of code
\lstset{language=lprolog}
\lstset{language=abella}
\textheight             632.01pt         % 46 lines exactly = 21.98cm  %
\title{On the Proof Theory of Property-Based Testing of Coinductive Specifications, or:\\
 PBT to Infinity and beyond}
% \author{Rob van Glabbeek
% \institute{NICTA\\ Sydney, Australia}
% \institute{School of Computer Science and Engineering\\
% University of New South Wales\thanks{A fine university.}\\
% Sydney, Australia}
% \email{rvg@cs.stanford.edu}
% \and
% Co Author \qquad\qquad Yet S. Else
% \institute{Stanford Univeristy\\
% California, USA}
% \email{\quad is@gmail.com \quad\qquad somebody@else.org}
% }
\author{Roberto Blanco
\institute{INRIA Paris, France}
\and Dale Miller
\institute{INRIA Saclay \\ LIX, \'Ecole Polytechnique, France}
\and Alberto Momigliano
\institute{DI, Universit\`a degli Studi di Milano, Italy}
}

\def\authorrunning{Blanco, Miller and Momigliano}
\def\titlerunning{PBT to Infinity and   beyond}
\begin{document}

\maketitle

Reasoning about infinite computations via coinduction and corecursion
has an ever-increasing relevance in formal methods and, in particular,
in the semantics of programming languages, starting
from~\cite{milner91tcs} (see~\cite{2007-Leroy-Grall} for a
compelling example) and, of course, coinduction underlies (the
meta-theory of) process calculi. This importance was acknowledged by researchers
in proof assistants, who promptly provided support for coinduction and
corecursion from the early '90s on: see~\cite{Paulson97,Gim95types}
for the beginning of the story concerning two popular frameworks.

It also became apparent that tools that search for
refutations/counter-examples of conjectures before attempting a
formal proof are invaluable: this is particularly true in PL theory,
where proofs tend to be shallow but may have hundreds of cases.  One
such approach is \emph{property-based testing} (PBT), which employs
automatic test data generation to try and refute executable
specifications.  Pioneered by \emph{QuickCheck} for functional
programming~\cite{claessen00icfp}, it has now spread to most major
proof assistants~\cite{BlanchetteBN11,QChick}.

In general, PBT does not extend immediately to testing coinductive specifications (an
exception being Isabelle's \emph{Nitpick}, which is, however, a
counter-model generator).  Extending Coq's
\emph{QuickChick}~\cite{QChick} to deal with Coq's notion of
coinduction via \emph{guarded} recursion (which is generally seen to
be a less than satisfactory approach to coinduction) is particularly
challenging.  We are not aware of applications of PBT to other forms
of coinduction, such as \emph{co-patterns}~\cite{AbelPTS13}.

While PBT originated in the functional programming community, we have
given in a previous paper (\cite{Blanco0M19}) a reconstruction of some
of its features (operational semantics, different flavors of
generation, shrinking) in proof-theoretic terms using \emph{focused
  proof systems}~\cite{andreoli92jlc,liang09tcs} and
\emph{Foundational Proof Certificates} (FPC)~\cite{chihani17jar}.  An
FPC can be used to define a range of proof structures, such as
resolution refutations, Herbrand disjuncts, tableaux, etc.
%
In the context of PBT, the proof theory setup is rather simple.
Consider an attempt to find counter-examples to a conjecture of the
form \(\forall x [(\tau(x)\wedge P(x)) \supset Q(x)]\) where $\tau$ is
a typing predicate and $P$ and $Q$ are two other predicates defined
using Horn clause specifications.
%
The negation of this conjecture is
\(\exists x [(\tau(x)\land P(x)) \land \neg Q(x)]\).
%
In searching for a focused proof of this negation, the \emph{positive
  phase} (which corresponds to the generation of possible
counter-examples) is represented by \(\exists x\) and \((\tau(x)\land
P(x))\).
%
That phase is followed by the \emph{negative phase} (which correspond
to counter-example testing) and is represented by \(\neg Q(x)\).
%
FPCs are simple logic programs that guide the search for potential
counter-examples using different generation strategies; they further
capture diverse features such as $\delta$-debugging, fault isolation,
explanation, etc.  Such a range of features can be programmed as the
\emph{clerks and experts} predicates~\cite{chihani17jar} that decorate
the sequent rules used in an FPC proof checking kernel: the kernel is
also able to do a limited amount of proof reconstruction.


% As explained in~\cite{Blanco0M19}, the standard PBT setup needs little
% more than Horn logic. % specifications.
% %
% However, when addressing potentially infinite computations, we need
% richer specifications.  While coinductive logic programming (see for
% example~\cite{Luke07} and~\cite{BasoldKL19}) may at first seem to fit
% the bill, the need to model infinite \emph{behavior} rather than
% infinite objects (i.e., (ir)rational terms on the domain of discourse)
% has lead us to adopt a much stronger logic with explicit rules for
% induction and coinduction.
% As explained in~\cite{Blanco0M19}, the standard PBT setup needs little
% more than Horn logic. % specifications.
%
%% new paragraph for R2
There are at least two ways to address potentially infinite
computations in logical terms. We can introduce infinite terms,
rational or even irrational, in our semantics, as already accounted
for in Lloyd's textbook and in~\cite{maher88lics}: % same as Maher88 ?
this has recently
been revisited in \emph{coinductive logic programming}, see, for
example,~\cite{Luke07} and the definitive~\cite{BasoldKL19}. Or we can
concentrate on modeling infinite \emph{behavior} of finite terms, for
example, divergence of a given (finite) program. We choose the latter and this requires a
logic stronger than a logic programming interpreter, namely one with explicit rules for induction and coinduction.

A natural choice for such a logic is the fixed point logic $\cal
G$~\cite{gacek11ic} % Gacek2012 is not best reference for G
and its linear logic cousin
$\mu\mathrm{MALL}$~\cite{Baelde12}, which are associated to the
\emph{Abella} proof assistant~\cite{baelde14jfr} and the \emph{Bedwyr}
model-checker.  In fact, the latter has already been used for related
aims~\cite{HeathM15}.

For a concrete example, consider a \emph{coinductive} definition
for CBV evaluation in the $\lambda$-calculus with constants
(following~\cite{2007-Leroy-Grall}). Using Bedwyr's
concrete syntax, this is written as: 
\begin{verbatim}
Define coinductive coeval: tm -> tm -> prop by
 coeval (con C) (con C);
 coeval (fun R) (fun R);
 coeval (app M N) V := 
   exists R W, coeval M (fun R) /\ coeval N W /\ coeval (R W) V.
\end{verbatim}
As is well-known, co-evaluation fails to be deterministic, since a divergent
term such as $\Omega$ co-evaluates to anything.  We can confirm this by
searching for a proof of the following formula:
\begin{verbatim}
exists E V1 V2, coeval E V1 /\ coeval E V2 /\ (V1 = V2 -> false)
\end{verbatim}
Proving this query entails a way to generate such (finite) terms and then checking,
with a crucial appeal to the coinduction, that they are in the required relation.

Other applications of PBT include separating the various
notions of equivalences in the lambda-calculus and various process
calculi: for example,  applicative and ground similarity in
PCFL~\cite{PITobtpe}, or analogous standard results in the
$\pi$-calculus.
%
While similar goals have been achieved in the literature for labeled transition
systems (using, for example, the \emph{Concurrency
  Workbench}), it is a remarkable feature of the proof-theoretic
setting that we can generalize PBT from a system without bindings
(say, CCS) to a system with bindings (say, the $\pi$-calculus).
%
Such ease is possible since proof theory accommodates the
\emph{$\lambda$-tree syntax} approach to treating
bindings~\cite{miller18jar}: in particular, both Abella and Bedwyr
include the $\nabla$ quantifier~\cite{miller05tocl}.

In our current setup, we attempt to find counter-examples using
Bedwyr to execute both the generation of test cases (controlled by
using specific FPCs~\cite{Blanco0M19}) and the testing phase.
%
Such an implementation of PBT allows us to
piggyback on Bedwyr's facilities for efficient proof 
search via tabling for (co)inductive predicates.
%
The treatment of the negation in the testing phase is, as usual, a
sticky point~\cite{Momigliano00}.
%
%One approach to eliminating negation from intuitionistic specification
%can be based on the techniques in.
%
However, if we identify, as we do, the proof theory behind model
checking as based on the linear logic $\mu$MALL~\cite{HeathM19}, in
that setting, occurrences of negations can be eliminated by using De
Morgan duality and inequality.


\bibliographystyle{eptcs}
\bibliography{../colp,../../ppdp19/l}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  Coinductive QuickCheck utf inputenc fontenc Herbrand
%  LocalWords:  corecursion coinductive corecursive QuickChick CBV ir
%  LocalWords:  disjuncts PCFL LTS Harrop PBT Coq's coinductively CCS
%  LocalWords:  intuitionistic FPCs Bedwyr Bedwyr's
