* Front matter
  Title:
  Authors: Blanco, Manighetti, Miller, Momigliano

* Abstract
* Introduction

  In several of the most popular interactive theorem provers (e.g.,
  Coq, Isabelle, and HOL), functional programming languages are used
  to implement the proof refinement process (often via tactics and
  tacticals).  

  We note that there are at least the following three observations
  that suggest that logic programming might make a more appropriate
  language than functional programming languages.

  1. Starting with one of the earliest such interactive theorem
     provers, where the ML programming language had its debut, it was
     clear that non-functional features of programming were needed.
     For example, the failure of tactic to be applicable to a goal was
     signaled using an exception mechanization.  Of course, in the
     logic programming paradigm, failure, success, and backtracking
     search are part of its core features.

  2. Features such as question-mark variables (meta-variables), hints,
     and unification have been added to, say, Coq.  Of course, logic
     programming supports such features directly.

  3. Computing flexibility with bindings within term structures is a
     challenge for functional programmers to address, at least in a
     canonical fashion.  Here, the logic programming paradigm comes
     with a completely clean and canonical mechanism for computing with
     bindings using Church's simultaneous treatment of term-level and
     formula-level (quantifiers) bindings and Gentzen's proof-level
     binding mechanism (eigenvariables).

  In this paper, we develop two applications of logic programming in
  support of tasks associated with using Coq. These tasks are:

  1. proof certificate elaboration and proof checking

  2. property based testing of proposed Coq theorems.

  In both of these tasks, the bulk of the processing is performed with
  the ELPI plugin to Coq.  ELPI is an implementation of lambda Prolog
  with a suitable api to allow ELPI to communicate with the Coq
  environment and the Coq kernel.

  We add our examples to those of others have done similar things, in
  particular [cite some of Enrico's recent papers].

* FPC

  Provide enough background here for both parts of the paper.
  However, the two parts of the paper have different needs: one part
  has undefined predicates (ie, has atoms) and the other part provides
  inductive definitions for all predicates.  The proof systems are a
  bit different.

  Some high-level description:

  A naive use of logic programming in support of deduction is to try
  to use a logic program to search directly for proofs of a theorem.
  Such attempts fail to find proofs for many reasons: a major one
  involves the fact that the control mechanism in a logic programming
  language is global and fixed.  The foundational proof certificate
  setting can be seen as providing a (partial) control mechanism to
  guide a naive interpreter.

* Proof elaboration

  Take scope for this work from the LFMTP 2020 paper with Rob/Matteo/Dale.

* Property based testing

  Take scope for this work from the PPDP 2019 paper with Rob/Alberto/Dale.

* Conclusion

