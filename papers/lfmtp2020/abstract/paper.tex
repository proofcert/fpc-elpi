\RequirePackage[utf8]{inputenc}
\RequirePackage[T1]{fontenc}
\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{LFMTP 2020}
\usepackage{url,xcolor}
\usepackage{xspace}
\newcommand{\lP}{$\lambda$Prolog\xspace}
\newcommand{\LKF}{\hbox{\sl LKF}\xspace}
\newcommand{\LJF}{\hbox{\sl LJF}\xspace}
\newcommand{\fpccoq}{FPC-Coq\xspace}

\title{Linking a \lP proof checker to the Coq kernel\\
       An extended abstract}
\author{Roberto Blanco
\institute{INRIA Paris, France}
\and Matteo Manighetti and 
\institute{INRIA Saclay \\ LIX, \'Ecole Polytechnique, France}
\and Dale Miller
\institute{INRIA Saclay \\ LIX, \'Ecole Polytechnique, France}}
\def\authorrunning{Blanco, Manighetti, and Miller}
\def\titlerunning{Linking a \lP proof checker to the Coq kernel}

\begin{document}
\maketitle

\noindent\textbf{Synopsis.}  The Coq kernel works with a specific form
of proof structure, and that proof structure is fully detailed.  In
particular, the Coq kernel performs type-checking on a dependently
typed $\lambda$-term.  If type checking succeeds, the formula
corresponding to its type is, in fact, a theorem of intuitionistic
logic.  Most external-to-Coq theorem provers do not generally build
such detailed, dependently typed $\lambda$-terms for proofs.  To the
extent that theorem provers output proof objects (called \emph{proof
  certificates} here), their structure can vary a great deal.  Also,
since some details can be reconstructed, they are seldom traced and
inserted into proof certificates.  In this extended abstract, we
describe the design of the \fpccoq system that can take externally
generated proof certificates and elaborate them into the kind of proof
structures required by the Coq kernel.  This \emph{elaboration} system
is built using three technologies: (1) the foundational proof
certificate (FPC) framework \cite{chihani17jar} that allows for the
specification of a wide range of proof certificates, (2) the \lP
programming language \cite{miller12proghol} that can interpret a given
FPC definition and then perform both proof checking and proof
reconstruction \cite{blanco17phd,blanco17cade}, and (3) the Coq-Elpi
plugin \cite{coq-elpi20web}, which embeds the Elpi implementation
\cite{dunchev15lpar} of \lP into Coq.

\bigskip

Consider an external (to Coq) prover capable of exporting its proofs
as certificates in some particular format.  Such a theorem prover (for
intuitionistic logic) is unlikely to build the detailed $\lambda$-term
required by the Coq kernel.  More likely, its notion of a proof
certificate is, instead, a trace of some key aspects of a proof: some
proof details might not be captured in such a trace.  For example:
\begin{enumerate}
\item Substitution instances of quantifiers might not be recorded in a
  proof since such instances can, in principle, be reconstructed using
  unification.

\item Detailed typing information might not need to be stored within a
  proof certificate since types can often be reconstructed during
  proof checking.

\item Some simplifications steps might be applied within a proof
  without recording which rewrites were used.  A simple
  non-deterministic proof-search engine might be expected to
  reconstruct an equivalent simplification.
\end{enumerate}
The FPC framework can be used to formally define the proof evidence of
many different formats \cite{chihani17jar} including those with such
details missing.  Combining such a definition, which is a simple logic
program, with an FPC proof checking kernel yields a complete logic
programming proof kernel.  During proof checking, unification and
backtracking search can infer missing proof details.  The FPC
framework also allows for the convenient capture and reorganization of
such details and, as a result, it can be used to build proof
structures appropriate for the Coq kernel.

Given its origins in the theory of focused sequent calculus, our first
FPC proof checker implements a purely declarative sequent calculus
proof checker, along the lines described in \cite{chihani17jar}.  We
have also developed a second approach to building a proof checker
based on dependent types in the style of \cite{lengrand10lmcs}.  This
second approach allows for a more concise implementation, where there
is no translation needed from Coq formulas to intuitionistic formulas
since the kernel directly operates with dependent types. The usual FPC
definitions of proof certificates remain directly usable also in this
context.

The code for both of these implementations is available at
\url{https://github.com/proofcert/fpc-elpi}.  It is important to
recognize that both \lP and Coq-Elpi can be seen as parts of a tool
chain, connecting an external prover to the Coq kernel and that these
two pieces of technology do not need to be trusted by the Coq kernel. 

The current version of \fpccoq only works on proving theorems in
first-order intuitionistic logic.  We also assume that external proof
certificates are in a format that is formally defined by some given
FPC: examples of such formats which have already been developed are
resolution refutations, Hilbert proofs, de Bruijn notation, and
natural deduction \cite{chihani17jar}.  Given that the \lP proof
checker internally implements \LJF (a focused version of
intuitionistic sequent calculus \cite{liang09tcs}), it can also serve
as a proof checker for \LKF (its classical counterpart).  As a result,
\fpccoq can be used to prove double-negation translations of a formula
for which there is a proof certificate in classical logic
\cite{chihani17jar}.  Extending the FPC framework to involve inductive
and coinductive reasoning has also been considered
\cite{heath15pxtp,heath19jar}, and a future version of \fpccoq could
include proof certificates that are output from inductive theorem
provers as well as model checkers.

\bibliographystyle{eptcs}
%\bibliography{../../references/master}
\begin{thebibliography}{10}
\providecommand{\bibitemdeclare}[2]{}
\providecommand{\surnamestart}{}
\providecommand{\surnameend}{}
\providecommand{\urlprefix}{Available at }
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\href}[2]{\texttt{#2}}
\providecommand{\urlalt}[2]{\href{#1}{#2}}
\providecommand{\doi}[1]{doi:\urlalt{http://dx.doi.org/#1}{#1}}
\providecommand{\bibinfo}[2]{#2}

\bibitemdeclare{phdthesis}{blanco17phd}
\bibitem{blanco17phd}
\bibinfo{author}{Roberto \surnamestart Blanco\surnameend}
  (\bibinfo{year}{2017}): \emph{\bibinfo{title}{Applications for Foundational
  Proof Certificates in theorem proving}}.
\newblock Ph.D. thesis, \bibinfo{school}{Universit{\'e} Paris-Saclay}.
\newblock \urlprefix\url{https://tel.archives-ouvertes.fr/tel-01743857}.

\bibitemdeclare{inproceedings}{blanco17cade}
\bibitem{blanco17cade}
\bibinfo{author}{Roberto \surnamestart Blanco\surnameend},
  \bibinfo{author}{Zakaria \surnamestart Chihani\surnameend} \&
  \bibinfo{author}{Dale \surnamestart Miller\surnameend}
  (\bibinfo{year}{2017}): \emph{\bibinfo{title}{Translating Between Implicit
  and Explicit Versions of Proof}}.
\newblock In \bibinfo{editor}{Leonardo \surnamestart de~Moura\surnameend},
  editor: {\sl \bibinfo{booktitle}{Automated Deduction - {CADE} 26 - 26th
  International Conference on Automated Deduction, Gothenburg, Sweden, August
  6-11, 2017, Proceedings}}, {\sl \bibinfo{series}{Lecture Notes in Computer
  Science}} \bibinfo{volume}{10395}, \bibinfo{publisher}{Springer}, pp.
  \bibinfo{pages}{255--273}, \doi{10.1007/978-3-319-63046-5\_16}.

\bibitemdeclare{article}{chihani17jar}
\bibitem{chihani17jar}
\bibinfo{author}{Zakaria \surnamestart Chihani\surnameend},
  \bibinfo{author}{Dale \surnamestart Miller\surnameend} \&
  \bibinfo{author}{Fabien \surnamestart Renaud\surnameend}
  (\bibinfo{year}{2017}): \emph{\bibinfo{title}{A semantic framework for proof
  evidence}}.
\newblock {\sl \bibinfo{journal}{J. of Automated Reasoning}}
  \bibinfo{volume}{59}(\bibinfo{number}{3}), pp. \bibinfo{pages}{287--330},
  \doi{10.1007/s10817-016-9380-6}.
\newblock \urlprefix\url{https://doi.org/10.1007/s10817-016-9380-6}.

\bibitemdeclare{inproceedings}{dunchev15lpar}
\bibitem{dunchev15lpar}
\bibinfo{author}{Cvetan \surnamestart Dunchev\surnameend},
  \bibinfo{author}{Ferruccio \surnamestart Guidi\surnameend},
  \bibinfo{author}{Claudio~Sacerdoti \surnamestart Coen\surnameend} \&
  \bibinfo{author}{Enrico \surnamestart Tassi\surnameend}
  (\bibinfo{year}{2015}): \emph{\bibinfo{title}{{ELPI:} Fast, Embeddable,
  $\lambda${Prolog} Interpreter}}.
\newblock In \bibinfo{editor}{Martin \surnamestart Davis\surnameend},
  \bibinfo{editor}{Ansgar \surnamestart Fehnker\surnameend},
  \bibinfo{editor}{Annabelle \surnamestart McIver\surnameend} \&
  \bibinfo{editor}{Andrei \surnamestart Voronkov\surnameend}, editors: {\sl
  \bibinfo{booktitle}{Logic for Programming, Artificial Intelligence, and
  Reasoning - 20th International Conference, {LPAR-20} 2015}}, {\sl \bibinfo{series}{LNCS}}
  \bibinfo{volume}{9450}, \bibinfo{publisher}{Springer}, pp.
  \bibinfo{pages}{460--468}, \doi{10.1007/978-3-662-48899-7\_32}.

\bibitemdeclare{inproceedings}{heath15pxtp}
\bibitem{heath15pxtp}
\bibinfo{author}{Quentin \surnamestart Heath\surnameend} \&
  \bibinfo{author}{Dale \surnamestart Miller\surnameend}
  (\bibinfo{year}{2015}): \emph{\bibinfo{title}{A framework for proof
  certificates in finite state exploration}}.
\newblock In \bibinfo{editor}{Cezary \surnamestart Kaliszyk\surnameend} \&
  \bibinfo{editor}{Andrei \surnamestart Paskevich\surnameend}, editors: {\sl
  \bibinfo{booktitle}{Proceedings of the Fourth Workshop on Proof eXchange for
  Theorem Proving}}, {\sl \bibinfo{series}{Electronic Proceedings in
  Theoretical Computer Science}} \bibinfo{volume}{186}, pp.
  \bibinfo{pages}{11--26}, \doi{10.4204/EPTCS.186.4}.

\bibitemdeclare{article}{heath19jar}
\bibitem{heath19jar}
\bibinfo{author}{Quentin \surnamestart Heath\surnameend} \&
  \bibinfo{author}{Dale \surnamestart Miller\surnameend}
  (\bibinfo{year}{2019}): \emph{\bibinfo{title}{A proof theory for model
  checking}}.
\newblock {\sl \bibinfo{journal}{J. of Automated Reasoning}}
  \bibinfo{volume}{63}(\bibinfo{number}{4}), pp. \bibinfo{pages}{857--885},
  \doi{10.1007/s10817-018-9475-3}.

\bibitemdeclare{article}{lengrand10lmcs}
\bibitem{lengrand10lmcs}
\bibinfo{author}{{St\'ephane} \surnamestart Lengrand\surnameend},
  \bibinfo{author}{Roy \surnamestart Dyckhoff\surnameend} \&
  \bibinfo{author}{James \surnamestart McKinna\surnameend}
  (\bibinfo{year}{2011}): \emph{\bibinfo{title}{A Focused Sequent Calculus
  Framework for Proof Search in Pure Type Systems}}.
\newblock {\sl \bibinfo{journal}{Logical Methods in Computer Science}}
  \bibinfo{volume}{7}(\bibinfo{number}{1}).
\newblock
  \urlprefix\url{http://www.lix.polytechnique.fr/~lengrand/Work/Reports/TTSC09.pdf}.

\bibitemdeclare{article}{liang09tcs}
\bibitem{liang09tcs}
\bibinfo{author}{Chuck \surnamestart Liang\surnameend} \& \bibinfo{author}{Dale
  \surnamestart Miller\surnameend} (\bibinfo{year}{2009}):
  \emph{\bibinfo{title}{Focusing and Polarization in Linear, Intuitionistic,
  and Classical Logics}}.
\newblock {\sl \bibinfo{journal}{Theoretical Computer Science}}
  \bibinfo{volume}{410}(\bibinfo{number}{46}), pp. \bibinfo{pages}{4747--4768},
  \doi{10.1016/j.tcs.2009.07.041}.

\bibitemdeclare{book}{miller12proghol}
\bibitem{miller12proghol}
\bibinfo{author}{Dale \surnamestart Miller\surnameend} \&
  \bibinfo{author}{Gopalan \surnamestart Nadathur\surnameend}
  (\bibinfo{year}{2012}): \emph{\bibinfo{title}{Programming with Higher-Order
  Logic}}.
\newblock \bibinfo{publisher}{Cambridge University Press},
  \doi{10.1017/CBO9781139021326}.

\bibitemdeclare{misc}{coq-elpi20web}
\bibitem{coq-elpi20web}
\bibinfo{author}{Enrico \surnamestart Tassi\surnameend} (\bibinfo{year}{2020}):
  \emph{\bibinfo{title}{Coq plugin embedding {ELPI}}}.
\newblock \bibinfo{howpublished}{\url{https://github.com/LPCIC/coq-elpi}}.

\end{thebibliography}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%%  LocalWords:  inputenc fontenc Elpi minimalistic fpc Coq's
%%  LocalWords:  elpi 
